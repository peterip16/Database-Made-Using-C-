
Google logo Drive
Add to Drive
Project Part 2 & 34 items

db.cpp

db.h
PDF
p1list_2.pdf
PDF
p1list_3.pdf

/************************************************************
	Project#1:	CLP & DDL
 ************************************************************/

#include "db.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <time.h>

int main(int argc, char** argv)
{
	int rc = 0;
	token_list *tok_list=NULL, *tok_ptr=NULL, *tmp_tok_ptr=NULL;

	if ((argc != 2) || (strlen(argv[1]) == 0))
	{
		printf("Usage: db \"command statement\"");
		return 1;
	}
	rc = initialize_tpd_list();
    if (rc)
    {
		printf("\nError in initialize_tpd_list().\nrc = %d\n", rc);
    }
	else
	{
    rc = get_token(argv[1], &tok_list);

		/* Test code */
		tok_ptr = tok_list;
		while (tok_ptr != NULL)
		{
			printf("%16s \t%d \t %d\n",tok_ptr->tok_string, tok_ptr->tok_class,
				      tok_ptr->tok_value);
			tok_ptr = tok_ptr->next;
		}
    
		if (!rc)
		{	
			rc = do_semantic(tok_list);
			if(rc == 0)
			{
				tok_ptr = tok_list;
				if ((tok_ptr->tok_value != K_SELECT)
					&&(tok_ptr->tok_value != K_BACKUP)
					&&(tok_ptr->tok_value != K_RESTORE)
					&&(tok_ptr->tok_value != K_ROLLFORWARD)
					&&(g_tpd_list->db_flags != DOING_ROLLFORWARD))
				{
					FILE * fp;
    				fp = fopen ("db.log", "a+");
    				time_t rtime;
    				struct tm *info;
    				time( &rtime );
    				char *buffer;
    				buffer = (char *)calloc(15, sizeof(char));
    				info = localtime( &rtime );
    				strftime(buffer,15,"%Y%m%d%H%M%S", info);
					fprintf(fp,"%s \"%s\"\n",buffer,argv[1]);
					free(buffer);
        			fflush(fp);
        			fclose(fp);
				}
				if(tok_ptr->tok_value == K_BACKUP)
				{
					FILE * fp;
					fp = fopen ("db.log", "a+");
					fprintf(fp,"BACKUP %s\n",tok_ptr->next->next->tok_string);
        			fflush(fp);
        			fclose(fp);					
				}
			}
		}
		if (rc)
		{
			tok_ptr = tok_list;
			while (tok_ptr != NULL)
			{
				if ((tok_ptr->tok_class == error) ||
					  (tok_ptr->tok_value == INVALID))
				{
					printf("\nError in the string: %s\n", tok_ptr->tok_string);
					printf("rc=%d\n", rc);
					break;
				}
				tok_ptr = tok_ptr->next;
			}
		}

    /* Whether the token list is valid or not, we need to free the memory */
		tok_ptr = tok_list;
		while (tok_ptr != NULL)
		{
	      tmp_tok_ptr = tok_ptr->next;
	      free(tok_ptr);
	      tok_ptr=tmp_tok_ptr;
		}
	}
	return rc;
}

/************************************************************* 
	This is a lexical analyzer for simple SQL statements
 *************************************************************/
int get_token(char* command, token_list** tok_list)
{
	int rc=0,i,j;
	char *start, *cur, temp_string[MAX_TOK_LEN];
	bool done = false;
	start = cur = command;
	while (!done)
	{
		bool found_keyword = false;
		/* This is the TOP Level for each token */
	  	memset ((void*)temp_string, '\0', MAX_TOK_LEN);
		i = 0;
		/* Get rid of all the leading blanks */
		while (*cur == ' ')
			cur++;
		if (cur && isalpha(*cur))
		{
			// find valid identifier
			int t_class;
			do 
			{
				temp_string[i++] = *cur++;
			}
			while ((isalnum(*cur)) || (*cur == '_'));
			if (!(strchr(STRING_BREAK, *cur)))
			{
				/* If the next char following the keyword or identifier
				   is not a blank, (, ), or a comma, then append this
					 character to temp_string, and flag this as an error */
				temp_string[i++] = *cur++;
				add_to_list(tok_list, temp_string, error, INVALID);
				rc = INVALID;
				done = true;
			}
			else
			{
				// We have an identifier with at least 1 character
				// Now check if this ident is a keyword
				for (j = 0, found_keyword = false; j < TOTAL_KEYWORDS_PLUS_TYPE_NAMES; j++)
				{
                    if ((_stricmp(keyword_table[j], temp_string) == 0))
					{
						found_keyword = true;
						break;
					}
				}
				if (found_keyword)
				{
					if (KEYWORD_OFFSET+j < K_CREATE)
						t_class = type_name;
					else if (KEYWORD_OFFSET+j >= F_SUM)
            			t_class = function_name;
          			else
					  t_class = keyword;
					add_to_list(tok_list, temp_string, t_class, KEYWORD_OFFSET+j);
				}
				else
				{
					if (strlen(temp_string) <= MAX_IDENT_LEN)
					{
					  add_to_list(tok_list, temp_string, identifier, IDENT);
					}
					else
					{
						add_to_list(tok_list, temp_string, error, INVALID);
						rc = INVALID;
						done = true;
					}
				}
				if (!*cur)
				{
					add_to_list(tok_list, "", terminator, EOC);
					done = true;
				}
			}
		}
		else if (isdigit(*cur))
		{
			// find valid number
			do 
			{
				temp_string[i++] = *cur++;
			}
			while (isdigit(*cur));

			if (!(strchr(NUMBER_BREAK, *cur)))
			{
				/* If the next char following the keyword or identifier
				   is not a blank or a ), then append this
					 character to temp_string, and flag this as an error */
				temp_string[i++] = *cur++;
				add_to_list(tok_list, temp_string, error, INVALID);
				rc = INVALID;
				done = true;
			}
			else
			{
				add_to_list(tok_list, temp_string, constant, INT_LITERAL);

				if (!*cur)
				{
					add_to_list(tok_list, "", terminator, EOC);
					done = true;
				}
			}
		}
		else if ((*cur == '(') || (*cur == ')') || (*cur == ',') || (*cur == '*')
		         || (*cur == '=') || (*cur == '<') || (*cur == '>'))
		{
			/* Catch all the symbols here. Note: no look ahead here. */
			int t_value;
			switch (*cur)
			{
				case '(' : t_value = S_LEFT_PAREN; break;
				case ')' : t_value = S_RIGHT_PAREN; break;
				case ',' : t_value = S_COMMA; break;
				case '*' : t_value = S_STAR; break;
				case '=' : t_value = S_EQUAL; break;
				case '<' : t_value = S_LESS; break;
				case '>' : t_value = S_GREATER; break;
			}

			temp_string[i++] = *cur++;

			add_to_list(tok_list, temp_string, symbol, t_value);

			if (!*cur)
			{
				add_to_list(tok_list, "", terminator, EOC);
				done = true;
			}
		}
    	else if (*cur == '\'')
    	{
      /* Find STRING_LITERRAL */
			int t_class;
      		cur++;
			do 
			{
				temp_string[i++] = *cur++;
			}
			while ((*cur) && (*cur != '\''));

      		temp_string[i] = '\0';

			if (!*cur)
			{
				/* If we reach the end of line */
				add_to_list(tok_list, temp_string, error, INVALID);
				rc = INVALID;
				done = true;
			}
      		else /* must be a ' */
      		{
        		add_to_list(tok_list, temp_string, constant, STRING_LITERAL);
        		cur++;
				if (!*cur)
				{
					add_to_list(tok_list, "", terminator, EOC);
					done = true;
        		}
      		}
    	}
		else
		{
			if (!*cur)
			{
				add_to_list(tok_list, "", terminator, EOC);
				done = true;
			}
			else
			{
				/* not a ident, number, or valid symbol */
				temp_string[i++] = *cur++;
				add_to_list(tok_list, temp_string, error, INVALID);
				rc = INVALID;
				done = true;
			}
		}
	}
  return rc;
}

void add_to_list(token_list **tok_list, char *tmp, int t_class, int t_value)
{
	token_list *cur = *tok_list;
	token_list *ptr = NULL;

	//printf("%16s \t%d \t %d\n",tmp, t_class, t_value);

	ptr = (token_list*)calloc(1, sizeof(token_list));
	strcpy(ptr->tok_string, tmp);
	ptr->tok_class = t_class;
	ptr->tok_value = t_value;
	ptr->next = NULL;
  	if (cur == NULL)
		*tok_list = ptr;
	else
	{
		while (cur->next != NULL)
		{
			cur = cur->next;
		}

		cur->next = ptr;
	}
	return;
}

int do_semantic(token_list *tok_list)
{
	int rc = 0, cur_cmd = INVALID_STATEMENT;
	bool unique = false;
  	token_list *cur = tok_list;
	if((g_tpd_list->db_flags != ROLLFORWARD_PENDING))
	{
		if ((cur->tok_value == K_CREATE) &&
				((cur->next != NULL) && (cur->next->tok_value == K_TABLE)))
		{	
			if(g_tpd_list->db_flags != DOING_ROLLFORWARD)
	    		printf("CREATE TABLE statement\n");
			cur_cmd = CREATE_TABLE;
			cur = cur->next->next;
		}
		else if ((cur->tok_value == K_DROP) &&
						((cur->next != NULL) && (cur->next->tok_value == K_TABLE)))
		{
			if(g_tpd_list->db_flags != DOING_ROLLFORWARD)
				printf("DROP TABLE statement\n");
			cur_cmd = DROP_TABLE;
			cur = cur->next->next;
		}
		else if ((cur->tok_value == K_LIST) &&
						((cur->next != NULL) && (cur->next->tok_value == K_TABLE)))
		{
			if(g_tpd_list->db_flags != DOING_ROLLFORWARD)
				printf("LIST TABLE statement\n");
			cur_cmd = LIST_TABLE;
			cur = cur->next->next;
		}
		else if ((cur->tok_value == K_LIST) &&
						((cur->next != NULL) && (cur->next->tok_value == K_SCHEMA)))
		{
			if(g_tpd_list->db_flags != DOING_ROLLFORWARD)
				printf("LIST SCHEMA statement\n");
			cur_cmd = LIST_SCHEMA;
			cur = cur->next->next;
		}
	  	else if ((cur->tok_value == K_INSERT)
	           && (cur->next != NULL)
	           && (cur->next->tok_value == K_INTO)
	           && (cur->next->next != NULL)
	           && (cur->next->next->next != NULL)
	           && (cur->next->next->next->tok_value == K_VALUES))
	  	{
	  		if(g_tpd_list->db_flags != DOING_ROLLFORWARD)
		    	printf("INSERT INTO statement\n");
		    cur_cmd = INSERT;
		    cur = cur->next->next;
	  	}
		else if ((cur->tok_value == K_SELECT)
		           && (cur->next != NULL))
		{
		    if(g_tpd_list->db_flags != DOING_ROLLFORWARD)
		    	printf("SELECT statement\n");
		    cur_cmd = SELECT;
		    cur = cur->next;
		}
		else if((cur->tok_value == K_DELETE)
				&&(cur->next != NULL)
				&&(cur->next->tok_value == K_FROM)
				&&(cur->next->next !=NULL))
		{
			if(g_tpd_list->db_flags != DOING_ROLLFORWARD)
				printf("DELETE FROM statement\n");
			cur_cmd = DELETE;
			cur = cur->next->next;
		}
		else if((cur->tok_value == K_UPDATE)
				&&(cur->next != NULL)
				&&(cur->next->next != NULL)
				&&(cur->next->next->tok_value == K_SET)
				&&(cur->next->next->next != NULL)
				&&(cur->next->next->next->next != NULL)
				&&(cur->next->next->next->next->tok_value == S_EQUAL)
				&&(cur->next->next->next->next->next != NULL))
		{
			if(g_tpd_list->db_flags != DOING_ROLLFORWARD)
				printf("UPDATE statement\n");
			cur_cmd = UPDATE;
			cur = cur->next;
		}
		else if (cur->tok_value == K_BACKUP)
		{
			if(g_tpd_list->db_flags != DOING_ROLLFORWARD)
				printf("BACKUP statement\n");
			cur_cmd = BACKUP;
			cur = cur->next;
		}
		else if((cur->tok_value == K_RESTORE)
				&&(cur->next->tok_value == K_FROM)
				&&(cur->next->next != NULL))
		{
			if(g_tpd_list->db_flags != DOING_ROLLFORWARD)
				printf("RESTORE FROM statement\n");
			cur_cmd = RESTORE;
			cur = cur->next->next;
		}
		else if(cur->tok_value == K_ROLLFORWARD)
		{
			if(g_tpd_list->db_flags != DOING_ROLLFORWARD)
				printf("NO ROLLFORWARD PENDING\n");
			rc = cur_cmd;
		}
		else
	  	{
	  		if(g_tpd_list->db_flags != DOING_ROLLFORWARD)
				printf("Invalid statement\n");
			rc = cur_cmd;
		}

		if (cur_cmd != INVALID_STATEMENT)
		{
			switch(cur_cmd)
			{
				case CREATE_TABLE:
							rc = sem_create_table(cur);
							break;
				case DROP_TABLE:
							rc = sem_drop_table(cur);
							break;
				case LIST_TABLE:
							rc = sem_list_tables();
							break;
				case LIST_SCHEMA:
							rc = sem_list_schema(cur);
							break;
	      		case INSERT:
				            rc = sem_insert(cur);
				            break;
            case SELECT:
                    rc = __sem_select(cur);
				            break;
				case DELETE:
							rc = sem_delete(cur);
							break;
				case UPDATE:
							rc = sem_update(cur);
							break;
				case BACKUP:
							rc = sem_backup(cur);
							break;
				case RESTORE:
							rc = sem_restore(cur);
							break;
	      		default:
							; /* no action */
			}
		}
	}
	else if(cur->tok_value == K_ROLLFORWARD)
	{
		printf("ROLLFORWARD statement\n");
		cur = cur->next;
		rc = sem_rollforward(cur);
	}
	else
	{
		printf("ROLLFORWARD PENDING\n");
		rc = DO_ROLLFOWARD;
	}
	return rc;
}

int sem_create_table(token_list *t_list)
{
	int rc = 0;
	token_list *cur;
	tpd_entry tab_entry;
	tpd_entry *new_entry = NULL;
	bool column_done = false;
	int cur_id = 0;
	cd_entry	col_entry[MAX_NUM_COL];


	memset(&tab_entry, '\0', sizeof(tpd_entry));
	cur = t_list;
	if ((cur->tok_class != keyword) &&
		  (cur->tok_class != identifier) &&
			(cur->tok_class != type_name))
	{
		// Error
		rc = INVALID_TABLE_NAME;
		cur->tok_value = INVALID;
	}
	else
	{
		if ((new_entry = get_tpd_from_list(cur->tok_string)) != NULL)
		{
			rc = DUPLICATE_TABLE_NAME;
			cur->tok_value = INVALID;
		}
		else
		{
			strcpy(tab_entry.table_name, cur->tok_string);
			cur = cur->next;
			if (cur->tok_value != S_LEFT_PAREN)
			{
				//Error
				rc = INVALID_TABLE_DEFINITION;
				cur->tok_value = INVALID;
			}
			else
			{
				memset(&col_entry, '\0', (MAX_NUM_COL * sizeof(cd_entry)));

				/* Now build a set of column entries */
				cur = cur->next;
				do
				{
					if ((cur->tok_class != keyword) &&
							(cur->tok_class != identifier) &&
							(cur->tok_class != type_name))
					{
						// Error
						rc = INVALID_COLUMN_NAME;
						cur->tok_value = INVALID;
					}
					else
					{
						int i;
						for(i = 0; i < cur_id; i++)
						{
              /* make column name case sensitive */
							if (strcmp(col_entry[i].col_name, cur->tok_string)==0)
							{
								rc = DUPLICATE_COLUMN_NAME;
								cur->tok_value = INVALID;
								break;
							}
						}

						if (!rc)
						{
							strcpy(col_entry[cur_id].col_name, cur->tok_string);
							col_entry[cur_id].col_id = cur_id;
							col_entry[cur_id].not_null = false;    /* set default */

							cur = cur->next;
							if (cur->tok_class != type_name)
							{
								// Error
								rc = INVALID_TYPE_NAME;
								cur->tok_value = INVALID;
							}
							else
							{
                /* Set the column type here, int or char */
								col_entry[cur_id].col_type = cur->tok_value;
								cur = cur->next;
		
								if (col_entry[cur_id].col_type == T_INT)
								{
									if ((cur->tok_value != S_COMMA) &&
										  (cur->tok_value != K_NOT) &&
										  (cur->tok_value != S_RIGHT_PAREN))
									{
										rc = INVALID_COLUMN_DEFINITION;
										cur->tok_value = INVALID;
									}
								  else
									{
										col_entry[cur_id].col_len = sizeof(int);
										
										if ((cur->tok_value == K_NOT) &&
											  (cur->next->tok_value != K_NULL))
										{
											rc = INVALID_COLUMN_DEFINITION;
											cur->tok_value = INVALID;
										}	
										else if ((cur->tok_value == K_NOT) &&
											    (cur->next->tok_value == K_NULL))
										{					
											col_entry[cur_id].not_null = true;
											cur = cur->next->next;
										}
	
										if (!rc)
										{
											/* I must have either a comma or right paren */
											if ((cur->tok_value != S_RIGHT_PAREN) &&
												  (cur->tok_value != S_COMMA))
											{
												rc = INVALID_COLUMN_DEFINITION;
												cur->tok_value = INVALID;
											}
											else
		                  {
												if (cur->tok_value == S_RIGHT_PAREN)
												{
 													column_done = true;
												}
												cur = cur->next;
											}
										}
									}
								}   // end of S_INT processing
								else
								{
									// It must be char()
									if (cur->tok_value != S_LEFT_PAREN)
									{
										rc = INVALID_COLUMN_DEFINITION;
										cur->tok_value = INVALID;
									}
									else
									{
										/* Enter char(n) processing */
										cur = cur->next;
		
										if (cur->tok_value != INT_LITERAL)
										{
											rc = INVALID_COLUMN_LENGTH;
											cur->tok_value = INVALID;
										}
										else
										{
											/* Got a valid integer - convert */
											col_entry[cur_id].col_len = atoi(cur->tok_string);
											cur = cur->next;
											
											if (cur->tok_value != S_RIGHT_PAREN)
											{
												rc = INVALID_COLUMN_DEFINITION;
												cur->tok_value = INVALID;
											}
											else
											{
												cur = cur->next;
						
												if ((cur->tok_value != S_COMMA) &&
														(cur->tok_value != K_NOT) &&
														(cur->tok_value != S_RIGHT_PAREN))
												{
													rc = INVALID_COLUMN_DEFINITION;
													cur->tok_value = INVALID;
												}
												else
												{
													if ((cur->tok_value == K_NOT) &&
														  (cur->next->tok_value != K_NULL))
													{
														rc = INVALID_COLUMN_DEFINITION;
														cur->tok_value = INVALID;
													}
													else if ((cur->tok_value == K_NOT) &&
																	 (cur->next->tok_value == K_NULL))
													{					
														col_entry[cur_id].not_null = true;
														cur = cur->next->next;
													}
		
													if (!rc)
													{
														/* I must have either a comma or right paren */
														if ((cur->tok_value != S_RIGHT_PAREN) &&															  (cur->tok_value != S_COMMA))
														{
															rc = INVALID_COLUMN_DEFINITION;
															cur->tok_value = INVALID;
														}
														else
													  {
															if (cur->tok_value == S_RIGHT_PAREN)
															{
																column_done = true;
															}
															cur = cur->next;
														}
													}
												}
											}
										}	/* end char(n) processing */
									}
								} /* end char processing */
							}
						}  // duplicate column name
					} // invalid column name

					/* If rc=0, then get ready for the next column */
					if (!rc)
					{
						cur_id++;
					}

				} while ((rc == 0) && (!column_done));
	
				if ((column_done) && (cur->tok_value != EOC))
				{
					rc = INVALID_TABLE_DEFINITION;
					cur->tok_value = INVALID;
				}

				if (!rc)
				{
					/* Now finished building tpd and add it to the tpd list */
					tab_entry.num_columns = cur_id;
					tab_entry.tpd_size = sizeof(tpd_entry) + 
															 sizeof(cd_entry) *	tab_entry.num_columns;
				  tab_entry.cd_offset = sizeof(tpd_entry);
					new_entry = (tpd_entry*)calloc(1, tab_entry.tpd_size);

					if (new_entry == NULL)
					{
						rc = MEMORY_ERROR;
					}
					else
					{
						memcpy((void*)new_entry,
							     (void*)&tab_entry,
									 sizeof(tpd_entry));
		
						memcpy((void*)((char*)new_entry + sizeof(tpd_entry)),
									 (void*)col_entry,
									 sizeof(cd_entry) * tab_entry.num_columns);
	
						rc = add_tpd_to_list(new_entry);

            //

            create_table_file(new_entry->table_name,new_entry);

						free(new_entry);
					}
				}
			}
		}
	}
  return rc;
}

int sem_drop_table(token_list *t_list)
{
	int rc = 0;
	token_list *cur;
	tpd_entry *tab_entry = NULL;

	cur = t_list;
	if ((cur->tok_class != keyword) &&
		  (cur->tok_class != identifier) &&
			(cur->tok_class != type_name))
	{
		// Error
		rc = INVALID_TABLE_NAME;
		cur->tok_value = INVALID;
	}
	else
	{
		if (cur->next->tok_value != EOC)
		{
			rc = INVALID_STATEMENT;
			cur->next->tok_value = INVALID;
		}
		else
		{
			if ((tab_entry = get_tpd_from_list(cur->tok_string)) == NULL)
			{
				rc = TABLE_NOT_EXIST;
				cur->tok_value = INVALID;
			}
			else
			{
				/* Found a valid tpd, drop it from tpd list */
				rc = drop_tpd_from_list(cur->tok_string);
			}
		}
	}

  char *file_name = (char *)calloc(strlen(cur->tok_string) + 5,sizeof(char));

  strcat(file_name,cur->tok_string);
  strcat(file_name,".dat");
  remove(file_name);
  free(file_name);

  return rc;
}

int sem_list_tables()
{
	int rc = 0;
	int num_tables = g_tpd_list->num_tables;
	tpd_entry *cur = &(g_tpd_list->tpd_start);

	if (num_tables == 0)
	{
		printf("\nThere are currently no tables defined\n");
	}
	else
	{
		printf("\nTable List\n");
		printf("*****************\n");
		while (num_tables-- > 0)
		{
			printf("%s\n", cur->table_name);
			if (num_tables > 0)
			{
				cur = (tpd_entry*)((char*)cur + cur->tpd_size);
			}
		}
		printf("****** End ******\n");
	}

  return rc;
}

int sem_list_schema(token_list *t_list)
{
	int rc = 0;
	token_list *cur;
	tpd_entry *tab_entry = NULL;
	cd_entry  *col_entry = NULL;
	char tab_name[MAX_IDENT_LEN+1];
	char filename[MAX_IDENT_LEN+1];
	bool report = false;
	FILE *fhandle = NULL;
	int i = 0;

	cur = t_list;

	if (cur->tok_value != K_FOR)
  {
		rc = INVALID_STATEMENT;
		cur->tok_value = INVALID;
	}
	else
	{
		cur = cur->next;

		if ((cur->tok_class != keyword) &&
			  (cur->tok_class != identifier) &&
				(cur->tok_class != type_name))
		{
			// Error
			rc = INVALID_TABLE_NAME;
			cur->tok_value = INVALID;
		}
		else
		{
			memset(filename, '\0', MAX_IDENT_LEN+1);
			strcpy(tab_name, cur->tok_string);
			cur = cur->next;

			if (cur->tok_value != EOC)
			{
				if (cur->tok_value == K_TO)
				{
					cur = cur->next;
					
					if ((cur->tok_class != keyword) &&
						  (cur->tok_class != identifier) &&
							(cur->tok_class != type_name))
					{
						// Error
						rc = INVALID_REPORT_FILE_NAME;
						cur->tok_value = INVALID;
					}
					else
					{
						if (cur->next->tok_value != EOC)
						{
							rc = INVALID_STATEMENT;
							cur->next->tok_value = INVALID;
						}
						else
						{
							/* We have a valid file name */
							strcpy(filename, cur->tok_string);
							report = true;
						}
					}
				}
				else
				{ 
					/* Missing the TO keyword */
					rc = INVALID_STATEMENT;
					cur->tok_value = INVALID;
				}
			}

			if (!rc)
			{
				if ((tab_entry = get_tpd_from_list(tab_name)) == NULL)
				{
					rc = TABLE_NOT_EXIST;
					cur->tok_value = INVALID;
				}
				else
				{
					if (report)
					{
						if((fhandle = fopen(filename, "a+tc")) == NULL)
						{
							rc = FILE_OPEN_ERROR;
						}
					}

					if (!rc)
					{
						/* Find correct tpd, need to parse column and index information */

						/* First, write the tpd_entry information */
						printf("Table PD size            (tpd_size)    = %d\n", tab_entry->tpd_size);
						printf("Table Name               (table_name)  = %s\n", tab_entry->table_name);
						printf("Number of Columns        (num_columns) = %d\n", tab_entry->num_columns);
						printf("Column Descriptor Offset (cd_offset)   = %d\n", tab_entry->cd_offset);
            			printf("Table PD Flags           (tpd_flags)   = %d\n\n", tab_entry->tpd_flags); 

						if (report)
						{
							fprintf(fhandle, "Table PD size            (tpd_size)    = %d\n", tab_entry->tpd_size);
							fprintf(fhandle, "Table Name               (table_name)  = %s\n", tab_entry->table_name);
							fprintf(fhandle, "Number of Columns        (num_columns) = %d\n", tab_entry->num_columns);
							fprintf(fhandle, "Column Descriptor Offset (cd_offset)   = %d\n", tab_entry->cd_offset);
              				fprintf(fhandle, "Table PD Flags           (tpd_flags)   = %d\n\n", tab_entry->tpd_flags); 
						}

						/* Next, write the cd_entry information */
						for(i = 0, col_entry = (cd_entry*)((char*)tab_entry + tab_entry->cd_offset);
								i < tab_entry->num_columns; i++, col_entry++)
						{
							printf("Column Name   (col_name) = %s\n", col_entry->col_name);
							printf("Column Id     (col_id)   = %d\n", col_entry->col_id);
							printf("Column Type   (col_type) = %d\n", col_entry->col_type);
							printf("Column Length (col_len)  = %d\n", col_entry->col_len);
							printf("Not Null flag (not_null) = %d\n\n", col_entry->not_null);

							if (report)
							{
								fprintf(fhandle, "Column Name   (col_name) = %s\n", col_entry->col_name);
								fprintf(fhandle, "Column Id     (col_id)   = %d\n", col_entry->col_id);
								fprintf(fhandle, "Column Type   (col_type) = %d\n", col_entry->col_type);
								fprintf(fhandle, "Column Length (col_len)  = %d\n", col_entry->col_len);
								fprintf(fhandle, "Not Null Flag (not_null) = %d\n\n", col_entry->not_null);
							}
						}
	
						if (report)
						{
							fflush(fhandle);
							fclose(fhandle);
						}
					} // File open error							
				} // Table not exist
			} // no semantic errors
		} // Invalid table name
	} // Invalid statement

  return rc;
}

int sem_insert(token_list *t_list)
{
  int rc = 0;
  token_list *cur;
  tpd_entry *new_entry = NULL;

  FILE *fhandle = NULL;
  struct _stat file_stat;
  cur = t_list;

  rc = load_table(cur);
  if (rc == 0)//The table exists
  {

    int i = 0;
    char * table_file_name = (char *)calloc(strlen(cur->tok_string) + 5,sizeof(char));

    strcat(table_file_name,cur->tok_string);
    strcat(table_file_name,".dat");

    if ( rc == 0 )
    {
      cd_entry *col_entry = (cd_entry*)((char *)(tab_file_header->tpd_ptr) + sizeof(tpd_entry));
      new_entry = tab_file_header->tpd_ptr;


      token_list * prev = NULL;

      cur = cur->next->next;

      //If it is not lef paren "("
      if (cur->tok_value != S_LEFT_PAREN)
      {
        //Error
        rc = MISSING_LEFT_PAREN;
        cur->tok_value = INVALID;
      }
      else//It is left paren "("
      {


        bool can_end = false;
        int num_literal_processed = 0;
        if (cur->next != NULL)
          prev = cur;
        do
        {

          cur = cur->next;
          if(cur == NULL)
            break;


          if( num_literal_processed < new_entry->num_columns
              &&
              ((cur->tok_value == INT_LITERAL
                && col_entry[num_literal_processed].col_type != T_INT)
               ||
               (cur->tok_value == STRING_LITERAL
                && col_entry[num_literal_processed].col_type != T_CHAR)
               ||
               (cur->tok_value == K_NULL
                && col_entry[num_literal_processed].not_null)) )
          {

            rc = INVALID_LITERAL_VALUE;
            cur->tok_value = INVALID;
            break;
          }
          else//We can read more tokens
          {
            if(cur->tok_value == INT_LITERAL)
            {
              num_literal_processed++;
            }
            else if(cur->tok_value == STRING_LITERAL)
            {
              if(strlen(cur->tok_string) > col_entry[num_literal_processed].col_len)
              {
                rc = STRING_LARGER_THAN_EXPECTED;
                cur->tok_value = INVALID;
                break;
              }

              num_literal_processed++;
            }
            else if(cur->tok_value == K_NULL)
            {
              num_literal_processed++;
            }


            //If it is int or string
            if(cur->tok_value == INT_LITERAL
               || cur->tok_value == STRING_LITERAL
               || cur->tok_value == K_NULL)
            {
              cur = cur->next;
              if(cur == NULL)
                break;

              //If "," or ")"
              if(cur->tok_value != S_RIGHT_PAREN
                 && cur->tok_value != S_COMMA)
              {
                rc = MISSING_RIGHT_PAREN_OR_COMMA;
                cur->tok_value = INVALID;
                break;
              }
              else if(cur->tok_value == S_RIGHT_PAREN)
              {
                can_end = true;
                break;
              }
              else if(cur->tok_value == S_COMMA)//It is comma
              {
                if(cur->next->tok_value != INT_LITERAL
                   && cur->next->tok_value != STRING_LITERAL
                   && cur->next->tok_value != K_NULL)
                {
                  rc = UNEXPECTED_COMMA;
                  cur->tok_value = INVALID;
                  break;
                }

              }//It is comma

            }//If it is int or string
            else
            {
              if( cur->tok_value == S_RIGHT_PAREN
                  && num_literal_processed != new_entry->num_columns )
              {
                rc = MISSING_ARGUMENTS;
                cur->tok_value = INVALID;
              }
              else
              {
                cur->tok_value = INVALID;
                rc = UNEXPECTED_TOKEN;
              }
            }


          }//We can read more tokens

        }while(rc == 0);

        //Capture tokens after right paren(Unexpected tokens)
        if(rc == 0
           && cur->next != 0
           && cur->next->tok_value != EOC)
        {
          rc = UNEXPECTED_TOKEN;
          cur = cur->next;
          cur->tok_value = INVALID;
        }
        else if(rc == 0 && !can_end)
        {
          rc = MISSING_RIGHT_PAREN_OR_COMMA;
          cur->tok_value = INVALID;
        }
        //If insert was used with more parameters than expected
        else if(rc == 0 &&
                num_literal_processed != tab_file_header->tpd_ptr->num_columns)
        {
          cur->tok_value = INVALID;
          if(num_literal_processed < tab_file_header->tpd_ptr->num_columns)
            rc = MISSING_ARGUMENTS;
          else
            rc = MORE_ARGUMENTS_THAN_EXPECTED;
        }

        //It is a valid insert statement => insert the record
        if(rc == 0 && prev != NULL)
        {



          unsigned char * current_row = current_table_data[tab_file_header->num_records];

          i = 0;
          while ( prev->tok_value != EOC )
          {
            if(prev->tok_value == INT_LITERAL)
            {
              *current_row = 4;
              current_row++;
              int value;
              value = atoi(prev->tok_string);
              memcpy(current_row, &value,col_entry[i].col_len);
              current_row+=col_entry[i].col_len;
              i++;
            }
            else if(prev->tok_value == STRING_LITERAL)
            {
              int str_len = strlen(prev->tok_string);
              *current_row = str_len;
              current_row++;
              memcpy(current_row, prev->tok_string,sizeof(char)*str_len);
              current_row += col_entry[i].col_len;
              i++;
            }
            else if(prev->tok_value == K_NULL)
            {
              *current_row = 0;
              current_row += 1 + col_entry[i].col_len;
              i++;
            }
            prev = prev->next;
          }

          FILE *fhandle_append = NULL;
          //If the table file does not exist
          if( (fhandle_append = fopen(table_file_name, "w")) == NULL)
          {
            rc = FILE_OPEN_ERROR;
          }
          else
          {
            tab_file_header->num_records++;
            tab_file_header->file_size += tab_file_header->record_size;
            tab_file_header->tpd_ptr = 0;
            fwrite(tab_file_header,tab_file_header->record_offset,1,fhandle_append);
            for( int j = 0; j < tab_file_header->num_records; j++)
              fwrite(current_table_data[j],tab_file_header->record_size,1,fhandle_append);

            fflush(fhandle_append);
            fclose(fhandle_append);
          }
        }

      }//It is left paren "("


      delete_table_data();

    }//The table file is not corrupted



  }//The table exists

  return rc;
}

int sem_delete(token_list *t_list)
{
  int rc = 0;
  int ncol = -1;
  int drows = 0;
  token_list *cur;
  token_list *col = NULL;
  tpd_entry *new_entry = NULL;
  FILE *fhandle = NULL;
  unsigned char ** new_table_data = NULL;
  struct _stat file_stat;
  cur = t_list;
  rc = load_table(cur);
  int i = 0;
  int k = 0;
  int iter = 0;
  if (rc == 0)//The table exists and its not corrupted
  {
    char * table_file_name = (char *)calloc(strlen(cur->tok_string) + 5,sizeof(char));
    strcat(table_file_name,cur->tok_string);
    strcat(table_file_name,".dat");
    if(cur->next->tok_value == EOC)//Will delete all de rows in the table
    { 
    	printf("Deleted %d rows\n",tab_file_header->num_records);
  		tab_file_header->num_records = 0;
  		tab_file_header->file_size = sizeof(table_file_header);
  		tab_file_header->tpd_ptr = 0;
  		if((fhandle = fopen(table_file_name, "wbc")) == NULL)
		{
			rc = FILE_OPEN_ERROR;
		}
		else
		{
		    fwrite(tab_file_header, sizeof(table_file_header), 1, fhandle);
		    fflush(fhandle);
		    fclose(fhandle);
		}
		free(table_file_name);
    	delete_table_data();
    }
    else // delete rows depending on the WHERE statement
    {
    	if((cur->next->tok_value == K_WHERE)
    		&&(cur->next->next != NULL)
    		&&(cur->next->next->next != NULL)
    		&&(cur->next->next->next->next != NULL))
    	{
    		cur = cur->next->next;
    		col = cur;
    		cur = cur->next;
    		if((cur->tok_value == S_EQUAL)
    			||(cur->tok_value == S_GREATER)
    			||(cur->tok_value == S_LESS))
    		{
    			cd_entry *col_entry = (cd_entry*)((char *)(tab_file_header->tpd_ptr) + sizeof(tpd_entry));
    			new_table_data = (unsigned char**)malloc(100*sizeof(char*));
    			//Allocate memory for each record
          		for( i = 0; i < 100; i++ )
          		{
            		new_table_data[i] = (unsigned char*)malloc(tab_file_header->record_size);
                    memset(new_table_data[i],0,tab_file_header->record_size);
                }
				for( int j = 0; j < tab_file_header->tpd_ptr->num_columns; j++ )
				{
					if (strcmp(col_entry[j].col_name, col->tok_string)!=0)
					{
      				  	iter += col_entry[j].col_len;
      				}
      				else
      				{
      					iter += (j+1);
      					ncol = j;
      					break;
      				}
				}
				if(ncol >= 0)
				{
					for( i = 0; i < tab_file_header->num_records; i++)
					{
					unsigned char * current_row  = current_table_data[i];
  						if(col_entry[ncol].col_type==T_INT)
  						{
  							if(cur->next->tok_value == INT_LITERAL)
  							{
	  							int data = atoi(cur->next->tok_string);
	    						int size = (*(current_row+iter-1));
	    						current_row+=iter;
	    						if(size != 0) //if the record is null i do nothing
	    						{
	      							int value;
	      							memcpy(reinterpret_cast<char*>(&value),current_row,col_entry[ncol].col_len);
	      							if(cur->tok_value == S_EQUAL)
	      							{
			  							if(value != data)
			  							{
			  								memcpy(new_table_data[k],current_table_data[i],tab_file_header->record_size);
			  								k++;
			  							}
			  							else
			  							{
			  								drows++;
			  							}
	      							}
	      							else if(cur->tok_value == S_GREATER)
	      							{
	      								if(data > value)
			  							{
			  								memcpy(new_table_data[k],current_table_data[i],tab_file_header->record_size);
			  								k++;
			  							}
			  							else
			  							{
			  								drows++;
			  							}
	      							}
	      							else
	      							{
	      								if(data < value)
			  							{
			  								memcpy(new_table_data[k],current_table_data[i],tab_file_header->record_size);
			  								k++;
			  							}
			  							else
			  							{
			  								drows++;
			  							}
	      							}
	    						}
	    					}
	    					else
	    					{
			        			rc = INVALID_LITERAL_VALUE;
			        			cur->next->tok_value = INVALID;
	    					}
  						}
  						else if(col_entry[ncol].col_type==T_CHAR)
  						{
  							if(cur->next->tok_value == IDENT)
  							{
	    						int size = (int)*(current_row+iter-1);
	    						current_row+=iter;
	    						char data[256];
	    						memcpy(data,cur->next->tok_string,256);
	    						data[strlen(cur->next->tok_string)] = '\0';
	    						if( size != 0 )
	    						{
	    							char value[256];
	    							memcpy(value,current_row,size);
	    							value[size] = '\0';
	    							if(cur->tok_value == S_EQUAL)
	      							{
			  							if(strcmp(data,value) != 0)
			  							{
			  								memcpy(new_table_data[k],current_table_data[i],tab_file_header->record_size);
			  								k++;
			  							}
			  							else
			  							{
			  								drows++;
			  							}
	      							}
	      							else if(cur->tok_value == S_GREATER)
	      							{
	      								if(strcmp(value,data) < 0)
			  							{
			  								memcpy(new_table_data[k],current_table_data[i],tab_file_header->record_size);
			  								k++;
			  							}
			  							else
			  							{
			  								drows++;
			  							}
	      							}
	      							else
	      							{
	      								if(strcmp(value,data) > 0)
			  							{
			  								memcpy(new_table_data[k],current_table_data[i],tab_file_header->record_size);
			  								k++;
			  							}
			  							else
			  							{
			  								drows++;
			  							}
	      							}	                                
	    						}
	    					}
	    					else
	    					{
			        			rc = INVALID_LITERAL_VALUE;
			        			cur->next->tok_value = INVALID;
	    					}
    					}     						
					}
					if(drows > 0)
					{
						tab_file_header->num_records -=drows;
		        		tab_file_header->file_size -= (drows*tab_file_header->record_size);
						if( (fhandle = fopen(table_file_name, "wbc")) == NULL)
		      			{
		        			rc = FILE_OPEN_ERROR;
		      			}
		      			tab_file_header->tpd_ptr = 0;
		        		fwrite(tab_file_header,tab_file_header->record_offset,1,fhandle);
		        		for( int j = 0; j < tab_file_header->num_records; j++)
		          			fwrite(new_table_data[j],tab_file_header->record_size,1,fhandle);
						fflush(fhandle);
		        		fclose(fhandle);
		        		printf("Deleted %d rows\n",drows);
		        		free(table_file_name);
    					delete_table_data();
        			}
        			else
        			{
        				printf("WARNING: No rows found matching the contidition\n");
        			}
        		}
        		else
        		{
        			rc = COLUMN_NOT_EXIST;
        			col->tok_value = INVALID;
        		}
    		}
    		else
    		{
    			rc = INVALID_STATEMENT;
		        cur->tok_value = INVALID;
    		}

    	}
    	else
    	{
    		rc = INVALID_STATEMENT;
		    cur->next->tok_value = INVALID;
    	}
    }
  }//The table exists and its not corrupted
  
  if(new_table_data != NULL)
  {
    for( i = 0;  i < 100; i++)
    free(new_table_data[i]);
    free(new_table_data);
  }
  return rc;
}
int sem_update(token_list *t_list)
{
	int rc=0;
	int iter=0;
	int iter2=0;
	int ncol=-1;
	int ncol2=-1;
	int i = 0;
	int urows = 0;
	token_list *cur;
	FILE *fhandle = NULL;
	token_list *col = NULL;
  	cur = t_list;
  	col = cur->next->next;
  	rc = load_table(cur);
  	if(rc == 0)//The table exists and its not corrupted
  	{
  		char * table_file_name = (char *)calloc(strlen(cur->tok_string) + 5,sizeof(char));
	    strcat(table_file_name,cur->tok_string);
	    strcat(table_file_name,".dat");
	    cur = cur->next->next->next->next;
	    if(cur->next->tok_value == EOC)
	    {
	    	cd_entry *col_entry = (cd_entry*)((char *)(tab_file_header->tpd_ptr) + sizeof(tpd_entry));
    		for( int j = 0; j < tab_file_header->tpd_ptr->num_columns; j++ )
			{
				if (strcmp(col_entry[j].col_name, col->tok_string)!=0)
				{
  				  	iter += col_entry[j].col_len;
  				}
  				else
  				{
  					iter += (j+1);
  					ncol = j;
  					break;
  				}
  			}
			if(ncol >= 0)
			{
				for( i = 0; i < tab_file_header->num_records; i++)
				{
						unsigned char * current_row  = current_table_data[i];
						if(col_entry[ncol].col_type==T_INT)
						{
							if(cur->tok_value == INT_LITERAL)
							{
								int data = atoi(cur->tok_string);
								int size = (*(current_row+iter-1));
								current_row+=iter-1;
	  							*current_row = size;
						        current_row++;
						        memcpy(current_row, &data,col_entry[ncol].col_len);
	  							urows++;
	  						}
	  						else
	  						{
	  							rc = INVALID_LITERAL_VALUE;
		        				cur->tok_value = INVALID;
	  						}
	  					}
	  					else if(col_entry[ncol].col_type==T_CHAR)
	  					{
	  						if(cur->tok_value == IDENT)
	  						{
	    						current_row+=iter-1;
	    						int str_len = strlen(cur->tok_string);
              					*current_row = str_len;
              					current_row++;
              					memcpy(current_row, cur->tok_string,sizeof(char)*str_len);
              					urows++;
	  						}
	  						else
	  						{
	  							rc = INVALID_LITERAL_VALUE;
		        				cur->tok_value = INVALID;
	  						}
	  					}
	  			}
			}
			else
			{
			rc = COLUMN_NOT_EXIST;
			col->tok_value = INVALID;
			}
	    }
	    else if((cur->next->tok_value == K_WHERE)
    			&&(cur->next->next != NULL)
    			&&(cur->next->next->next != NULL)
    			&&(cur->next->next->next->next != NULL))
	    {
		    if((cur->next->next->next->tok_value == S_EQUAL)
					||(cur->next->next->next->tok_value == S_GREATER)
					||(cur->next->next->next->tok_value == S_LESS))
				{
			    	cd_entry *col_entry = (cd_entry*)((char *)(tab_file_header->tpd_ptr) + sizeof(tpd_entry));
		    		for( int j = 0; j < tab_file_header->tpd_ptr->num_columns; j++ )
					{
						if (strcmp(col_entry[j].col_name, col->tok_string)!=0)
						{
		  				  	iter += col_entry[j].col_len;
		  				}
		  				else
		  				{
		  					iter += (j+1);
		  					ncol = j;
		  					break;
		  				}
		  			}
		    		for( int j = 0; j < tab_file_header->tpd_ptr->num_columns; j++ )
					{
						if (strcmp(col_entry[j].col_name, cur->next->next->tok_string)!=0)
						{
		  				  	iter2 += col_entry[j].col_len;
		  				}
		  				else
		  				{
		  					iter2 += (j+1);
		  					ncol2 = j;
		  					break;
		  				}
		  			}

					if(ncol >= 0)
					{
						if(ncol2 >= 0)
						{
							for( i = 0; i < tab_file_header->num_records; i++)
							{
								unsigned char * current_row  = current_table_data[i];
								if(col_entry[ncol].col_type==T_INT)
								{
									if(cur->tok_value == INT_LITERAL)
									{
										if(col_entry[ncol2].col_type==T_INT)
										{
											if(cur->next->next->next->next->tok_value == INT_LITERAL)
											{
												int data = atoi(cur->tok_string);
									            int data2 = atoi(cur->next->next->next->next->tok_string);
					    						int size = (*(current_row+iter-1));
				      							int value;
				      							memcpy(reinterpret_cast<char*>(&value),current_row+iter2,col_entry[ncol2].col_len);
				      							if(cur->next->next->next->tok_value == S_EQUAL)
				      							{
						  							if(value == data2)
						  							{
						  								current_row+=iter-1;
				  										*current_row = size;
									        			current_row++;
						  								memcpy(current_row, &data,col_entry[ncol].col_len);
						  								urows++;
						  							}
				      							}
				      							else if(cur->next->next->next->tok_value == S_GREATER)
				      							{
				      								if(value > data2)
						  							{
						  								current_row+=iter-1;
				  										*current_row = size;
									        			current_row++;
						  								memcpy(current_row, &data,col_entry[ncol].col_len);
						  								urows++;
						  							}
				      							}
				      							else
				      							{
				      								if(value < data2)
						  							{
						  								current_row+=iter-1;
				  										*current_row = size;
									        			current_row++;
						  								memcpy(current_row, &data,col_entry[ncol].col_len);
						  								urows++;
						  							}
				      							}
											}
											else
											{
												rc = INVALID_LITERAL_VALUE;
		        								cur->next->next->next->next->tok_value = INVALID;
											}
										}
										else if(col_entry[ncol2].col_type==T_CHAR)
										{
											if(cur->next->next->next->next->tok_value == IDENT)
											{
												int data = atoi(cur->tok_string);
				    							char data2[256];
				    							memcpy(data2,cur->next->next->next->next->tok_string,256);
				    							data2[strlen(cur->next->next->next->next->tok_string)] = '\0';
					    						int size = (*(current_row+iter2-1));
					    						char value[256];
				    							memcpy(value,current_row+iter2,size);
				    							value[size] = '\0';
				      							if(cur->next->next->next->tok_value == S_EQUAL)
				      							{
						  							if(strcmp(value,data2) == 0)
						  							{
						  								current_row+=iter-1;
				  										*current_row = 4;
									        			current_row++;
						  								memcpy(current_row, &data,col_entry[ncol].col_len);
						  								urows++;
						  							}
				      							}
				      							else if(cur->next->next->next->tok_value == S_GREATER)
				      							{
				      								if(strcmp(value,data2) > 0)
						  							{
						  								current_row+=iter-1;
				  										*current_row = 4;
									        			current_row++;
						  								memcpy(current_row, &data,col_entry[ncol].col_len);
						  								urows++;
						              				}
				      							}
				      							else
				      							{
				      								if(strcmp(value,data2) < 0)
						  							{
						  								current_row+=iter-1;
				  										*current_row = 4;
									        			current_row++;
						  								memcpy(current_row, &data,col_entry[ncol].col_len);
						  								urows++;
						  							}
				      							}
											}
											else
											{
												rc = INVALID_LITERAL_VALUE;
		        								cur->next->next->next->next->tok_value = INVALID;												
											}
										}
									}
									else
									{
										rc = INVALID_LITERAL_VALUE;
		        						cur->tok_value = INVALID;
									}
								}
								else if(col_entry[ncol].col_type==T_CHAR)
								{
									if(cur->tok_value == IDENT)
									{
										if(col_entry[ncol2].col_type==T_INT)
										{
											if(cur->next->next->next->next->tok_value == INT_LITERAL)
											{
							                    int data2 = atoi(cur->next->next->next->next->tok_string);
				      							int value;
				      							memcpy(reinterpret_cast<char*>(&value),current_row+iter2,col_entry[ncol2].col_len);
				      							if(cur->next->next->next->tok_value == S_EQUAL)
				      							{
						  							if(value == data2)
						  							{
							    						current_row+=iter-1;
							    						int str_len = strlen(cur->tok_string);
						              					*current_row = str_len;
						              					current_row++;
						              					memcpy(current_row,cur->tok_string,sizeof(char)*str_len);
						              					urows++;
						  							}
				      							}
				      							else if(cur->next->next->next->tok_value == S_GREATER)
				      							{
				      								if(value > data2)
						  							{
							    						current_row+=iter-1;
							    						int str_len = strlen(cur->tok_string);
						              					*current_row = str_len;
						              					current_row++;
						              					memcpy(current_row,cur->tok_string,sizeof(char)*str_len);
						              					urows++;
						  							}
				      							}
				      							else
				      							{
				      								if(value < data2)
						  							{
							    						current_row+=iter-1;
							    						int str_len = strlen(cur->tok_string);
						              					*current_row = str_len;
						              					current_row++;
						              					memcpy(current_row,cur->tok_string,sizeof(char)*str_len);
						              					urows++;
						  							}
				      							}
											}
											else
											{
												rc = INVALID_LITERAL_VALUE;
		        								cur->next->next->next->next->tok_value = INVALID;														
											}
										}
										else if(col_entry[ncol2].col_type==T_CHAR)
										{
											if(cur->next->next->next->next->tok_value == IDENT)
											{
												char data2[256];
				    							memcpy(data2,cur->next->next->next->next->tok_string,256);
				    							data2[strlen(cur->next->next->next->next->tok_string)] = '\0';
					    						int size = (*(current_row+iter2-1));
					    						char value[256];
				    							memcpy(value,current_row+iter2,size);
				    							value[size] = '\0';
						    		            if(cur->next->next->next->tok_value == S_EQUAL)
				      							{
						  							if(strcmp(value,data2) == 0)
						  							{
							    						current_row+=iter-1;
							    						int str_len = strlen(cur->tok_string);
						              					*current_row = str_len;
						              					current_row++;
						              					memcpy(current_row,cur->tok_string,sizeof(char)*str_len);
						              					urows++;
						  							}
				      							}
				      							else if(cur->next->next->next->tok_value == S_GREATER)
				      							{
				      								if(strcmp(value,data2) > 0)
						  							{
							    						current_row+=iter-1;
							    						int str_len = strlen(cur->tok_string);
						              					*current_row = str_len;
						              					current_row++;
						              					memcpy(current_row,cur->tok_string,sizeof(char)*str_len);
						              					urows++;
						              				}
				      							}
				      							else
				      							{
				      								if(strcmp(value,data2) < 0)
						  							{
							    						current_row+=iter-1;
							    						int str_len = strlen(cur->tok_string);
						              					*current_row = str_len;
						              					current_row++;
						              					memcpy(current_row,cur->tok_string,sizeof(char)*str_len);
						              					urows++;
						  							}
				      							}

											}
											else
											{
												rc = INVALID_LITERAL_VALUE;
		        								cur->next->next->next->next->tok_value = INVALID;														
											}
										}									
									}
								}
							}
						}
						else
						{
							rc = COLUMN_NOT_EXIST;
							cur->next->next->tok_value = INVALID;
						}
					}
					else
					{
						rc = COLUMN_NOT_EXIST;
						col->tok_value = INVALID;						
					}
				}
				else
				{
					rc = INVALID_STATEMENT;
					cur->next->next->next->tok_value = INVALID;
				}
	    }
	    else
	    {
	    	rc = INVALID_STATEMENT;
	    	cur->next->tok_value = INVALID;
	    }
		if(urows > 0)
		{
			if( (fhandle = fopen(table_file_name, "wbc")) == NULL)
  			{
    			rc = FILE_OPEN_ERROR;
  			}
  			tab_file_header->tpd_ptr = 0;
    		fwrite(tab_file_header,tab_file_header->record_offset,1,fhandle);
    		for( int j = 0; j < tab_file_header->num_records; j++)
      			fwrite(current_table_data[j],tab_file_header->record_size,1,fhandle);
			fflush(fhandle);
    		fclose(fhandle);
    		printf("Updated %d rows\n",urows);
    		free(table_file_name);
			delete_table_data();
		}
		else
		{
			printf("WARNING: No rows updated\n");
		}

  	}//The table exists and its not corrupted
	return rc;
}


int __sem_select(token_list* t_list)
{
  int rc = 0;
  token_list* cur = t_list;
  select_statement_data* select_data = (select_statement_data*)calloc(1,sizeof(select_statement_data));

  rc = __sem_select_parse(cur, select_data);
  if(rc!=0)
    return rc;

  rc = __sem_select_semantic(select_data);
  if(rc!=0)
    return rc;



  for( int i = 0; i < 100; i++ )
  {
    select_data->workspace_table_data[i] = (unsigned char*)calloc(1,tab_file_header->record_size);
//    record_status[i] = -2;

    if( i < tab_file_header->num_records)
    {
      memcpy(select_data->workspace_table_data[i],current_table_data[i],tab_file_header->record_size);
      select_data->record_status[i] = -2;
    }
  }

  __sem_select_apply_conditions(select_data,select_data->workspace_table_data,select_data->record_status);

  __order_by(select_data,select_data->workspace_table_data,select_data->record_status);


  print_select_data(select_data);

  return rc;
}


int __sem_select_parse(token_list *t_list, select_statement_data *select_data)
{
  token_list* cur = t_list;
  select_data->has_aggregate = false;
  select_data->all_cols = false;
  select_data->order = NULL;

  if(is_aggregate(cur))
  {
    select_data->has_aggregate = true;
    select_data->aggregate_value = cur->tok_value;
    select_data->aggregate_tok = cur;
    cur = cur->next->next;
  }

  //-------------------------------------------------------------------
  //        Begin Process list of identifiers
  //-------------------------------------------------------------------
  if(cur->tok_class == identifier)
  {
    char str_dentifier[MAX_IDENT_LEN];
    strcpy(select_data->col_ident[0],cur->tok_string);
    select_data->col_ident_tok[0] = cur;
    select_data->num_col++;
    int  i = 1;

    //Process next ",columnIden"
    while(hasNextColum(cur,str_dentifier))
    {
      if(select_data->has_aggregate)
      {
        cur->tok_value = INVALID;
        return UNEXPECTED_TOKEN;
      }

      if(i >= MAX_NUM_COL)
        return MAX_COLUMN_EXCEEDED;

      strcpy(select_data->col_ident[i],cur->tok_string);
      select_data->col_ident_tok[i] = cur;
      select_data->num_col++;
      i++;
    }
  }
  else if(cur->tok_value == S_STAR)
  {
    if(select_data->has_aggregate)
    {
      if(select_data->aggregate_value == F_SUM
         || select_data->aggregate_value == F_AVG)
      {
        cur->tok_value = INVALID;
        return UNEXPECTED_TOKEN;
      }
    }
    select_data->all_cols = true;
  }
  //-------------------------------------------------------------------
  //        End Process list of identifiers
  //-------------------------------------------------------------------
  else
  {
    cur->tok_value = INVALID;
    return UNEXPECTED_TOKEN;
  }

  if(select_data->has_aggregate == true)
  {
  	  cur = cur->next->next;
  }
  else
  {
  	  cur = cur->next;
  }

  //Detect from token
  if(cur->tok_value != K_FROM)
  {
    cur->tok_value = INVALID;
    return INVALID_STATEMENT;
  }

  cur = cur->next;

  //Get table name
  if(cur!=NULL
     && cur->tok_class != identifier)
  {
    cur->tok_value = INVALID;
    return INVALID_STATEMENT;
  }

  select_data->table_name_tok = cur;

  cur = cur->next;

  //If it is end of command
  if(cur->tok_value == EOC)
  {
    return 0;
  }
  //Start processing Where
  else if(cur->tok_value == K_WHERE)
  {
    cur = cur->next;
    int rc  = __sem_select_where(cur,select_data);
    if(rc!=0)
      return rc;
  }

  if(cur->tok_value == EOC)
  {
    return 0;
  }
  //Start processing order
  else if(cur->tok_value == K_ORDER)
  {
    cur = cur->next;
    int rc  = __sem_select_order(cur,select_data);
    if(rc!=0)
      return rc;

    if(cur->tok_value == EOC)
    {
      return 0;
    }
  }


  //If the function did not return there is an error
  cur->tok_value = INVALID;
  return UNEXPECTED_TOKEN;
}

int __sem_select_semantic(select_statement_data *select_data)
{
  int rc = 0;

  //Check if the table exists
  rc = load_table(select_data->table_name_tok);
  if(rc!=0)
  {
    select_data->table_name_tok->tok_value = INVALID;
    return rc;
  }

  //Check if the all columns to be list exists
  for( int i = 0; i < select_data->num_col; i++ )
  {
    if(!colum_exist(select_data->col_ident[i]))
    {
      select_data->col_ident_tok[i]->tok_value = INVALID;
      return COLUMN_NOT_EXIST;
    }
  }

  //-------------------------------------------------------------------
  // Begin Check if the the columns used for conditions exist
  //-------------------------------------------------------------------
  if(select_data->first_condition != NULL)
  {
    if(!colum_exist(select_data->first_condition->col_name))
    {
      select_data->first_condition->col_name_tok->tok_value = INVALID;
      return COLUMN_NOT_EXIST;
    }
    else
    {
      if((get_column_type(select_data->first_condition->col_name) == T_INT
         && select_data->first_condition->value_tok->tok_value == STRING_LITERAL)
         ||
         (get_column_type(select_data->first_condition->col_name) == T_CHAR
                  && select_data->first_condition->value_tok->tok_value == INT_LITERAL))
      {

        select_data->first_condition->col_name_tok->tok_value = INVALID;
        return INVALID_LITERAL_VALUE;
      }

    }
  }

  if(select_data->second_condition != NULL)
  {
    if(!colum_exist(select_data->second_condition->col_name))
    {
      select_data->second_condition->col_name_tok->tok_value = INVALID;
      return COLUMN_NOT_EXIST;
    }
    else
    {
      if((get_column_type(select_data->second_condition->col_name) == T_INT
         && select_data->second_condition->value_tok->tok_value == STRING_LITERAL)
         ||
         (get_column_type(select_data->second_condition->col_name) == T_CHAR
                  && select_data->second_condition->value_tok->tok_value == INT_LITERAL))
      {
        select_data->second_condition->col_name_tok->tok_value = INVALID;
        return INVALID_LITERAL_VALUE;
      }

    }
  }
  //-------------------------------------------------------------------
  // End Check if the the columns used for conditions exist
  //-------------------------------------------------------------------



  //-------------------------------------------------------------------
  // Begin Check if the the column used for "order by" exists
  //-------------------------------------------------------------------
  if( select_data->order != NULL )
  {
    if(!colum_exist(select_data->order->col_name))
    {
      select_data->order->col_name_tok->tok_value = INVALID;
      return COLUMN_NOT_EXIST;
    }
  }
  //-------------------------------------------------------------------
  // End Check if the the column used for "order by" exists
  //-------------------------------------------------------------------


  if(select_data->all_cols)
  {
    int num_cols = tab_file_header->tpd_ptr->num_columns;
    cd_entry *col_entry = (cd_entry*)((char*)tab_file_header->tpd_ptr + sizeof(tpd_entry));

    for( int i = 0; i < num_cols; i++ )
    {
      strcpy(select_data->col_ident[i],col_entry[i].col_name);
    }
    select_data->num_col = num_cols;
  }

  if(select_data->has_aggregate)
  {
    if((select_data->aggregate_value == F_SUM)||(select_data->aggregate_value == F_AVG))
    {
      if(get_column_type(select_data->col_ident[0]) != T_INT)
      {
        select_data->col_ident_tok[0]->tok_value = INVALID;
        return INVALID_FUNCTION_PARAMETER;
      }
    }
  }

  return 0;
}





int __sem_select_where(token_list*& cur, select_statement_data *select_data)
{
  int rc = 0;

  select_data->first_condition = NULL;
  select_data->second_condition = NULL;


  if(cur->tok_class == identifier)
  {
    select_data->first_condition =
        (select_statement_codition*) calloc(1,sizeof(select_statement_codition));

    strcpy(select_data->first_condition->col_name,cur->tok_string);
    select_data->first_condition->col_name_tok = cur;
  }
  else
  {
    cur->tok_value = INVALID;
    return MISSING_ARGUMENTS;
  }

  cur = cur->next;

  rc = is_condition(cur,select_data->first_condition);

  if( rc != 0 )
    return rc;

  //End with one condition
  if(cur->tok_value == EOC)
  {
    return 0;
  }
  //If there is another condition
  else if(cur->tok_value == K_OR
          || cur->tok_value == K_AND)
  {
    select_data->logical_operator = cur->tok_value;
    cur = cur->next;
    //read the column name
    if(cur->tok_class == identifier)
    {
      select_data->second_condition =
          (select_statement_codition*) calloc(1,sizeof(select_statement_codition));
      strcpy(select_data->second_condition->col_name,cur->tok_string);
      select_data->second_condition->col_name_tok = cur;

    }
    else
    {
      cur->tok_value = INVALID;
      return MISSING_ARGUMENTS;
    }
    cur = cur->next;

    //read the condition
    rc = is_condition(cur,select_data->second_condition);

    if( rc != 0 )
      return rc;

  }

  return 0;
}




int __sem_select_order(token_list*& cur, select_statement_data* select_data)
{


  select_data->order = (select_statement_order*)malloc(sizeof(select_statement_order));

  select_data->order->desc = false;

  if(cur->tok_value != K_BY)
  {
    cur->tok_value = INVALID;
    return UNEXPECTED_TOKEN;
  }

  cur = cur->next;

  if(cur->tok_class != identifier)
  {
    cur->tok_value = INVALID;
    return UNEXPECTED_TOKEN;
  }

  strcpy(select_data->order->col_name,cur->tok_string);
  select_data->order->col_name_tok = cur;

  cur = cur->next;

  if(cur->tok_value == K_DESC)
  {
    select_data->order->desc = true;
    cur = cur->next;
  }


  return 0;
}



int __sem_select_apply_conditions(select_statement_data* select_data,
                                  unsigned char * workspace_table_data[100],
                                  int record_status[100])
{

  select_statement_codition* condition;
  condition = select_data->first_condition;

  if(condition == NULL)
  {
    for( int i = 0; i < tab_file_header->num_records; i++)
    {
      record_status[i] = -1;
    }
    return -1;//Make all rows valid
  }
 

  for(int i=0;i<select_data->num_col;i++)
  {
  	int col_type = get_column_type(select_data->col_ident[i]);
  	if(col_type == T_INT)
  	{
  			printf(" %10s", select_data->col_ident[i]);
  	}
  	else if(col_type == T_CHAR)
  	{
  		    printf(" %-14s", select_data->col_ident[i]);
  	}
  }
  printf("\n");
  for( int i = 0; i < tab_file_header->num_records; i++)
  {
    char* str_value =  get_col_value(workspace_table_data[i], condition->col_name);

    if(evaluate_condition(condition,str_value))
    {
      record_status[i] = -1;
    }
  }

  condition = select_data->second_condition;

  if(condition == NULL)
    return -1;//Make all rows valid
  for( int i = 0; i < tab_file_header->num_records; i++)
  {
    char* str_value =  get_col_value(workspace_table_data[i], condition->col_name);
    if(select_data->logical_operator == K_OR)
    {
      if(evaluate_condition(condition,str_value))
      {
        record_status[i] = -1;
      }
    }
    else
    {
      if(evaluate_condition(condition,str_value) && select_data->record_status[i]==-1)
      {
        record_status[i] = -1;
      }
      else if(select_data->record_status[i]==-1)
      {
        record_status[i] = -2;
      }
    }
  }
}


int __order_by(select_statement_data* select_data, unsigned char *workspace_table_data[],int record_status[100])
{
  if(select_data->order == NULL)
    return -1;



  //5,3,2,1 ...
  {
    int col_type= get_column_type(select_data->order->col_name);

    for( int j  = 0; j < tab_file_header->num_records; j++ )
    {
      if(select_data->record_status[j] != -1)
        continue;

      for( int i  = 0; i < tab_file_header->num_records; i ++ )
      {

        if(select_data->record_status[i] != -1)
          continue;

        if(col_type == T_INT)
        {
          char* str_value1 = get_col_value(select_data->workspace_table_data[j],select_data->order->col_name);
          char* str_value2 = get_col_value(select_data->workspace_table_data[i],select_data->order->col_name);

          //If it isnot null
          str_value1++;
          str_value2++;
          int value1;
          int value2;
          if(str_value1[0]!=0)
          {
            memcpy(&value1,str_value1,sizeof(int));
            memcpy(&value2,str_value2,sizeof(int));


            if(select_data->order->desc)
            {
              if(value1 > value2)
              {
                unsigned char* tmp_ptr = select_data->workspace_table_data[j];
                select_data->workspace_table_data[j] = select_data->workspace_table_data[i];
                select_data->workspace_table_data[i] = tmp_ptr;
              }
            }
            else
            {
              if(value1 < value2)
              {
                unsigned char* tmp_ptr = select_data->workspace_table_data[j];
                select_data->workspace_table_data[j] = select_data->workspace_table_data[i];
                select_data->workspace_table_data[i] = tmp_ptr;
              }
            }
          }
        }
        else if(col_type == T_CHAR)
        {
          char* str_value1 = get_col_value(select_data->workspace_table_data[j],select_data->order->col_name);
          char* str_value2 = get_col_value(select_data->workspace_table_data[i],select_data->order->col_name);

          //If it isnot null
          str_value1++;
          str_value2++;
          if(str_value1[0]!=0)
          {
            if(select_data->order->desc)
            {
              if(strcmp(str_value1, str_value2) > 0)
              {
                unsigned char* tmp_ptr = select_data->workspace_table_data[j];
                select_data->workspace_table_data[j] = select_data->workspace_table_data[i];
                select_data->workspace_table_data[i] = tmp_ptr;
              }
            }
            else
            {
              if(strcmp(str_value1, str_value2) < 0)
              {
                unsigned char* tmp_ptr = select_data->workspace_table_data[j];
                select_data->workspace_table_data[j] = select_data->workspace_table_data[i];
                select_data->workspace_table_data[i] = tmp_ptr;
              }

            }


          }



        }

      }

    }


  }


}



bool evaluate_condition(select_statement_codition* condition, char* str_value)
{
  /*
  *  1 IS NULL
  *  2 IS NOT NULL
  * 	S_LESS
  *  S_GREATER
  *  S_EQUAL
  */


  switch (condition->type) {
    case 1://Is null
      if(str_value[0] == 0)
        return true;
      break;

    case 2://Is not null
      if(str_value[0] != 0)
        return true;
      break;

    case S_LESS:
      if(str_value[0] == 0)
        return false;
      if(condition->value_type == INT_LITERAL)
      {
        str_value++;
        int value;
        memcpy(&value,str_value,sizeof(int));
        return value < condition->int_value;
      }
      else
      {
        str_value++;
        return strcmp(str_value,condition->str_value) < 0;
      }

      break;


    case S_GREATER:
      if(str_value[0] == 0)
        return false;

      if(condition->value_type == INT_LITERAL)
      {
        str_value++;
        int value;
        memcpy(&value,str_value,sizeof(int));
        return value > condition->int_value;
      }
      else
      {
        str_value++;
        return strcmp(str_value,condition->str_value) > 0;
      }

      break;


    case S_EQUAL:
      if(str_value[0] == 0)
        return false;
      if(condition->value_type == INT_LITERAL)
      {
        str_value++;

        int value;
        memcpy(&value,str_value,sizeof(int));
        return value == condition->int_value;
      }
      else
      {
        str_value++;
        return strcmp(str_value,condition->str_value) == 0;
      }

      break;


  }

  return false;
}




char* get_col_value(unsigned char* current_row, char* col_name)
{
  int i = 0;
  cd_entry *col_entry = (cd_entry*)((char *)(tab_file_header->tpd_ptr) + sizeof(tpd_entry));

  //Print data

  for( int j = 0; j < tab_file_header->tpd_ptr->num_columns; j++)
  {
    if( strcmp(col_entry[j].col_name,col_name) == 0 )
    {
      char* str_value = (char*)calloc(col_entry[j].col_len+2,sizeof(char));
      memcpy(str_value,current_row,col_entry[j].col_len+1);
      return str_value;
    }
    current_row++;
    current_row+=col_entry[j].col_len;

  }
}







bool hasNextColum(token_list*& t_list,char* str_dentifier)
{
  bool expression = t_list!=NULL
      && t_list->next!=NULL
      && t_list->next->tok_value == S_COMMA
      && t_list->next->next != NULL
      && t_list->next->next->tok_class == identifier;

  if(expression)
  {
    strcpy(str_dentifier,t_list->next->next->tok_string);
    //Go to the last token processed
    t_list = t_list->next->next;
  }
  return expression;
}



int is_condition(token_list *&t_list, select_statement_codition* condition)
{
  if(t_list->tok_value == K_IS)
  {
    t_list = t_list->next;

    //If it is NULL
    if(t_list->tok_value == K_NULL)
    {
      condition->type = 1; //It means "IS NULL"
      condition->str_value = NULL;
      condition->value_tok = t_list;
      t_list = t_list->next;
      return 0;
    }
    //If it is not NULL
    else if(t_list->tok_value == K_NOT)
    {
      t_list = t_list->next;
      if(t_list->tok_value == K_NULL)
      {
        condition->type = 2; //It means "IS NULL"
        condition->value_tok = t_list;

        t_list = t_list->next;
        condition->str_value = NULL;

        return 0;
      }
    }
  }

  else if(t_list->tok_value == S_LESS
          || t_list->tok_value == S_GREATER
          || t_list->tok_value == S_EQUAL)
  {
    condition->type = t_list->tok_value;
    t_list = t_list->next;
    if(t_list->tok_value == INT_LITERAL)
    {
      condition->value_type = INT_LITERAL;
      condition->int_value = atoi(t_list->tok_string);
      condition->value_tok = t_list;
      t_list = t_list->next;
      return 0;
    }
    else if(t_list->tok_value == STRING_LITERAL)
    {
      condition->value_type = STRING_LITERAL;
      condition->str_value = strdup(t_list->tok_string);
      condition->value_tok = t_list;
      t_list = t_list->next;
      return 0;
    }
    else
    {
      t_list->tok_value = INVALID;
      return UNEXPECTED_TOKEN;
    }

  }


  t_list->tok_value = INVALID;
  return UNEXPECTED_TOKEN;

}


bool is_aggregate(token_list*& t_list)
{
  if( t_list->tok_value == F_SUM
      || t_list->tok_value == F_AVG
      || t_list->tok_value == F_COUNT)
  {
    return true;
  }
  return false;
}


bool colum_exist(const char * column_name)
{
  cd_entry *col_entry = (cd_entry*)((char*)tab_file_header->tpd_ptr + sizeof(tpd_entry));

  for( int i = 0; i < tab_file_header->tpd_ptr->num_columns; i++)
  {
    if(_stricmp(col_entry[i].col_name,column_name) == 0)
      return  true;
  }

  return false;
}

int get_column_type(const char * column_name)
{
  cd_entry *col_entry = (cd_entry*)((char*)tab_file_header->tpd_ptr + sizeof(tpd_entry));

  for( int i = 0; i < tab_file_header->tpd_ptr->num_columns; i++)
  {
    if(_stricmp(col_entry[i].col_name,column_name) == 0)
    {
      return col_entry[i].col_type;
    }
  }

  return 0;
}



int get_column_len(const char * column_name)
{
  cd_entry *col_entry = (cd_entry*)((char*)tab_file_header->tpd_ptr + sizeof(tpd_entry));

  for( int i = 0; i < tab_file_header->tpd_ptr->num_columns; i++)
  {
    if(_stricmp(col_entry[i].col_name,column_name) == 0)
    {
      return col_entry[i].col_len;
    }
  }
  return 0;
}






void print_select_data(select_statement_data* select_data)
{
  int count = 0;

  if(select_data->has_aggregate)
  {
    for( int  i = 0; i < tab_file_header->num_records; i++ )
    {
      if(select_data->record_status[i]==-1)
        count++;
    }
  }

  if(select_data->has_aggregate && select_data->aggregate_value == F_COUNT)
  {
  	if(select_data->all_cols == true)
  	{
  		 	printf("COUNT(*)\n");
    		printf("      %d\n",count);
    		return;
  	}
  	else
  	{
 		printf("COUNT(%s)\n",select_data->col_ident[0]);
    	printf("       %d\n",count);
    	return;
  	}
  }

  int acum = 0;//For sum and avg

  //Print data
  for(int row_idx = 0; row_idx < tab_file_header->num_records; row_idx++)
  {
    if(select_data->record_status[row_idx] < -1)
      continue;

    unsigned char * current_row  = select_data->workspace_table_data[row_idx];
    for(int i = 0; i < select_data->num_col; i++)
    {
      char* str_value = get_col_value(current_row, select_data->col_ident[i]);
      int col_type = get_column_type(select_data->col_ident[i]);
      int col_len = get_column_len(select_data->col_ident[i]);

      if(col_type==T_INT)
      {
        int size = (*str_value);
        str_value++;
        if(size != 0)
        {
          int value;
          memcpy(reinterpret_cast<char*>(&value),str_value,col_len);
          if(!select_data->has_aggregate)
            printf(" %10d",value);
          else
            acum +=value;
        }
        else
        {
          if(!select_data->has_aggregate)
            printf(" %10s","NULL");
        }
      }

      else if(col_type==T_CHAR)
      {
        int size = (int)*str_value;
        str_value++;

        if( size != 0 )
        {
          char value[256];
          memcpy(value,str_value,size);
          value[size] = '\0';
          printf(" %-14s",value);
        }
        else
          printf(" %-14s","NULL");
        str_value += col_len;
      }
    }

    if(!select_data->has_aggregate)
      printf("\n");
  }

  if(select_data->has_aggregate
     && select_data->aggregate_value == F_SUM)
  {
  		printf("SUM(%s)\n",select_data->col_ident[0]);
  	    printf("     %d\n",acum);
  }
  else if(select_data->has_aggregate
     && select_data->aggregate_value == F_AVG)
  {
  		printf("AVG(%s)\n",select_data->col_ident[0]);
    	printf("     %f\n",(float)acum/(float)count);
  }

}


void print_select_data_condition(select_statement_codition* condition)
{
  printf("Condition: %s ",condition->col_name);
  if(condition->type == 1)
    printf("IS NULL\n");
  else if(condition->type == 2)
    printf("IS NOT NULL\n");
  else
  {
    if(condition->type == S_LESS)
      printf("< ");
    else if(condition->type == S_EQUAL)
      printf("= ");
    else if(condition->type == S_GREATER)
      printf("> ");

    if(condition->value_type == INT_LITERAL)
      printf("%d",condition->int_value);
    else if(condition->value_type == STRING_LITERAL)
      printf("%s",condition->str_value);

    printf("\n");
  }

}





int sem_backup(token_list *t_list)
{
	token_list *cur = NULL;
	cur = t_list;
	int rc = 0;
		if(cur->tok_value == K_TO)
		{
			if(cur->next->tok_value == IDENT)
			{
				if(cur->next->next->tok_value == EOC)
				{

					FILE *file = NULL;
					FILE *temp = NULL;
					unsigned char *buffer = NULL;
					tpd_entry *tab = &(g_tpd_list->tpd_start);
					int num_tables = g_tpd_list->num_tables;
  					char * b_file_name = (char *)calloc(strlen(cur->next->tok_string) + 3,sizeof(char));
  					char * t_file_name;
	    			strcat(b_file_name,cur->next->tok_string);
	    			strcat(b_file_name,".bk");
					if(!file_exist(b_file_name))
					{
						struct _stat file_stat;    			
						file = fopen(b_file_name, "wb");
						temp = fopen("dbfile.bin", "rb");
	    				_fstat(_fileno(temp), &file_stat);
						fwrite(g_tpd_list,g_tpd_list->list_size, 1, file);
						fflush(temp);
						fclose(temp);
						if(g_tpd_list->list_size == file_stat.st_size)
						{
							while(num_tables-- > 0)
							{
								t_file_name = (char *)calloc(strlen(tab->table_name) + 5,sizeof(char));
								strcat(t_file_name,tab->table_name);
		    					strcat(t_file_name,".dat");
		    					temp = fopen(t_file_name, "rb");
		    					_fstat(_fileno(temp), &file_stat);
		    					tab_file_header = (table_file_header*)calloc(1, sizeof(table_file_header));
		    					fread(tab_file_header, sizeof(table_file_header), 1, temp);
		    					fseek(temp,0, SEEK_SET);
		    					if(tab_file_header->file_size == file_stat.st_size)
		    					{
			  						int size =  file_stat.st_size;
			  						fwrite(&size,sizeof(int), 1, file);
			  						buffer = (unsigned char*)calloc(size,sizeof(char));
			  						fread(buffer,size,1,temp);
			  						fwrite(buffer,size, 1,file);												
									if (num_tables > 0)
									{
										tab = (tpd_entry*)((char*)tab + tab->tpd_size);
									}
								}
								else
								{
									rc = DBFILE_CORRUPTION;
									printf("Table File: %s is corrupted\n",tab->table_name);
	         						printf("Real Size:%d != Actual Size:%d\n\n",tab_file_header->file_size,file_stat.st_size);
									fflush(file);
									fclose(file);
									fflush(temp);
									fclose(temp);
									remove(b_file_name);
	         						return rc;
								}
							}
						}
						else
						{
									rc = DBFILE_CORRUPTION;
									printf("DbFile is corrupted\n");
	         						printf("Real Size:%d != Actual Size:%d\n\n",g_tpd_list->list_size,file_stat.st_size);
									fflush(file);
									fclose(file);
									fflush(temp);
									fclose(temp);							
						}
						fflush(file);
						fclose(file);
						fflush(temp);
						fclose(temp);
					}
					else
					{
						rc = BACKUP_FILE_ALREADY_EXIST;
						cur->next->tok_value = INVALID;
					}
					free(buffer);
				}
				else
				{
					rc = MORE_ARGUMENTS_THAN_EXPECTED;
					cur->next->next->tok_value = INVALID;		
				}
			}
			else
			{
				rc = MISSING_ARGUMENTS;
				cur->next->tok_value =INVALID;
			}
		}
		else
		{
			rc = MISSING_ARGUMENTS;
			cur->tok_value =INVALID;
		}
	return rc;
}

int sem_restore(token_list *t_list)
{
	int rc=0;
	token_list *cur = NULL; 
	cur = t_list;
	if(cur->tok_value == IDENT)
	{
		FILE *fp = NULL;
		FILE *fp2 = NULL;
		char *buffer = NULL;
		char *temp_char = NULL;
		char *temp = NULL;
		char * b_file_name = (char *)calloc(strlen(cur->tok_string) + 4,sizeof(char));
	    strcat(b_file_name,cur->tok_string);
	    strcat(b_file_name,".bk");
		char * l_file_name = (char *)calloc(7,sizeof(char));
	    strcat(l_file_name,"db.old");
	    char *t_file_name = NULL;
	    rename("db.log","db.old");
	    temp = (char *)calloc(strlen(cur->tok_string) + 11,sizeof(char));
	    strcat(temp,"BACKUP ");
	    strcat(temp,cur->tok_string);
	    temp[strlen(cur->tok_string) + 11] = '\0';
	    buffer = (char *)calloc(256,sizeof(char));
	    temp_char = (char *)calloc(256,sizeof(char));
	    int size = NULL;
	    if(file_exist(b_file_name))
	    {
	    	if(file_exist(l_file_name))
	    	{
	    		if((cur->next->tok_value == EOC)
	    			||((cur->next->tok_value == K_WITHOUT)&&(cur->next->next->tok_value == K_RF)))
	    		{
			    	if(cur->next->tok_value == EOC)
			    	{
			    		fp = fopen(l_file_name, "r+");
			    		fp2 = fopen("db.log","w");
			    		while(fgets (buffer, 256, fp) != NULL)
			    		{
			    			memcpy(temp_char,buffer,256);
			    			buffer[6] = '\0';
			    			if(strcmp(buffer,"BACKUP\0") != 0)
			    			{
			    				fprintf(fp2, "%s",temp_char);
			    			}
			    			else if(strcmp(buffer,"BACKUP\0") == 0)
			    			{	
			    				temp_char[strlen(temp_char)-1] ='\0';
			    				if(strcmp(temp_char,temp) == 0)
			    				{
			    					fprintf(fp2,"%s\n",temp_char);
			    					fprintf(fp2, "%s\n","RF_START");
				    				FILE *in = NULL; 
				    				FILE *tout = NULL;
				    				tpd_list *tlist = NULL;
			    					in = fopen(b_file_name, "rb");
			    					unsigned char *file_buffer = NULL;
			    					struct _stat file_stat;
			    					_fstat(_fileno(in), &file_stat);
			    					file_buffer = (unsigned char*)calloc(file_stat.st_size,sizeof(char)); //Buffer long enough
			    					tout = fopen("dbfile.bin","wb");
			    					fread(&size, sizeof(int), 1, in);
				    				fseek(in,0, SEEK_SET);
				    				fread(file_buffer,size,1,in);
				    				fseek(in,0, SEEK_SET);
				    				tlist =(tpd_list*)calloc(1,size);
				    				fread(tlist, size, 1, in);
				    				tlist->db_flags = ROLLFORWARD_PENDING;
				    				fwrite(tlist,size,1,tout);
				    				tpd_entry *tab = &(tlist->tpd_start);
									int num_tables = tlist->num_tables;
									fflush(tout);
									fclose(tout);
									while(num_tables-- > 0)
									{
										t_file_name = (char *)calloc(strlen(tab->table_name) + 6,sizeof(char));
										strcat(t_file_name,tab->table_name);
			    						strcat(t_file_name,".dat");;
			    						tout = fopen(t_file_name, "wb");
										fread(&size, sizeof(int), 1, in);
				  						fread(file_buffer,size,1,in);
				  						fwrite(file_buffer,size,1,tout);
				  						if (num_tables > 0)
										{
											tab = (tpd_entry*)((char*)tab + tab->tpd_size);
										}
										fflush(tout);
										fclose(tout);
										free(t_file_name);
									}
			    				}
			    				else
			    				{
			    					fprintf(fp2, "%s\n", temp_char);
			    				}
			    			}
			    			else
			    			{
			    				rc = MISSING_BACKUP_LOG;
			    				printf("ERROR: MISSING LOG BAKCUP IN THE LOG  FILE\n");
			    			}
			    		}
		    			fflush(fp);
		    			fclose(fp);
		    			fflush(fp2);
		    			fclose(fp2);	    
		    			free(buffer);
		    			free(temp_char);
		    			remove("db.old");
			    	}
			    	else if(cur->next->tok_value == K_WITHOUT)
			    	{
			    		fp = fopen(l_file_name, "r+");
			    		fp2 = fopen("db.log","w");
			    		while(fgets (buffer, 256, fp) != NULL)
			    		{
			    			memcpy(temp_char,buffer,256);
			    			buffer[6] = '\0';
			    			if(strcmp(buffer,"BACKUP\0") != 0)
			    			{
			    				fprintf(fp2, "%s",temp_char);
			    			}
			    			else if(strcmp(buffer,"BACKUP\0") == 0)
			    			{	
			    				temp_char[strlen(temp_char)-1] ='\0';
			    				if(strcmp(temp_char,temp) == 0)
			    				{
			    					fprintf(fp2,"%s\n",temp_char);
				    				FILE *in = NULL; 
				    				FILE *tout = NULL;
				    				tpd_list *tlist = NULL;
			    					in = fopen(b_file_name, "rb");
			    					unsigned char *file_buffer = NULL;
			    					struct _stat file_stat;
			    					_fstat(_fileno(in), &file_stat);
			    					file_buffer = (unsigned char*)calloc(file_stat.st_size,sizeof(char)); //Buffer long enough
			    					tout = fopen("dbfile.bin","wb");
			    					fread(&size, sizeof(int), 1, in);
				    				fseek(in,0, SEEK_SET);
				    				fread(file_buffer,size,1,in);
				    				fseek(in,0, SEEK_SET);
				    				tlist =(tpd_list*)calloc(1,size);
				    				fread(tlist, size, 1, in);
				    				fwrite(file_buffer,size,1,tout);
				    				tpd_entry *tab = &(tlist->tpd_start);
									int num_tables = tlist->num_tables;
									fflush(tout);
									fclose(tout);
									while(num_tables-- > 0)
									{
										t_file_name = (char *)calloc(strlen(tab->table_name) + 6,sizeof(char));
										strcat(t_file_name,tab->table_name);
			    						strcat(t_file_name,".dat");;
			    						tout = fopen(t_file_name, "wb");
										fread(&size, sizeof(int), 1, in);
				  						fread(file_buffer,size,1,in);
				  						fwrite(file_buffer,size,1,tout);
				  						if (num_tables > 0)
										{
											tab = (tpd_entry*)((char*)tab + tab->tpd_size);
										}
										fflush(tout);
										fclose(tout);
										free(t_file_name);
									}
									break;
			    				}
			    				else
			    				{
			    					fprintf(fp2, "%s\n", temp_char);
			    				}
			    			}
			    			else
			    			{
			    				rc = MISSING_BACKUP_LOG;
			    				printf("ERROR: MISSING BACKUP LOG\n");
			    			}
			    		}
			    		if(fgets (buffer, 256, fp) != NULL)
			    		{
			    			int k = 1;
			    			char number[5];
			    			char *file_name = (char *)calloc(10,sizeof(char));
			    			strcat(file_name,"db.log");
//			    			itoa(k, number, 10);
                			sprintf(number,"%d",k);
                			strcat(file_name,number);
			    			while(file_exist(file_name))
			    			{
			    				k++;
			    				free(file_name);
			    				file_name = (char *)calloc(10,sizeof(char));
			    				strcat(file_name,"db.log");
//			    				itoa(k, number, 10);
                  				sprintf(number,"%d",k);
                  				strcat(file_name,number);
			    			}
		    				fflush(fp);
		    				fclose(fp);
			    			rename("db.old",file_name);
			    			
			    		}
		    			fflush(fp);
		    			fclose(fp);
		    			fflush(fp2);
		    			fclose(fp2);	    
		    			free(buffer);
		    			free(temp_char);
			    	}
			    	else	
			    	{
			    		rename("db.old","db.log");
				    	rc = LOG_FILE_NOT_EXIST;
				    	cur->tok_value = INVALID;
			    	}
			    }
			    else
			    {
			    	rename("db.old","db.log");
			    	rc = INVALID_STATEMENT;
			    	cur->next->tok_value = INVALID;
			    }
		    }
	    }
	    else
	    {
	    	rename("db.old","db.log");
	    	rc = BACKUP_FILE_NOT_EXIST;
	    	cur->tok_value = INVALID;
	    }
	}
	else
	{
		rc = INVALID_LITERAL_VALUE;
		cur->tok_value = INVALID;
	}
	return rc;
}

int sem_rollforward(token_list *t_list)
{
	int rc = 0;
	token_list *cur = NULL; 
	cur = t_list;
	FILE *fp;
	FILE *fp2;
	FILE *dbfile;
	FILE *aux;
	char *buffer;
	char *temp_char;
	char *tolog;
	char *date;
	bool found = false;
	time_t rtime1;
	time_t rtime2;
	bool prune = false;
	if(cur->tok_value == EOC)
	{
		if(file_exist("db.log"))
		{
			fp = fopen("dbfile.bin", "wb");
			g_tpd_list->db_flags = 0;
			fwrite(g_tpd_list,g_tpd_list->list_size, 1,fp);
			fflush(fp);
			fclose(fp);
			fp = NULL;
			rename("db.log","db.old");
			fp = fopen("db.old","r");
			aux = fopen("db.log","w");
			buffer = (char *)calloc(500,sizeof(char));
			temp_char = (char *)calloc(20,sizeof(char));
			while(fgets (buffer, 500, fp) != NULL)
			{
				token_list *tok_list=NULL, *tok_ptr=NULL, *tmp_tok_ptr=NULL;
				if(found == true)
				{
			    	fprintf(aux, "%s", buffer);
			    	buffer[strlen(buffer)-2] = '\0';
			    	get_token((buffer+16), &tok_list);
				    do_semantic(tok_list);
				}
				if(found == false)
				{
			    	memcpy(temp_char,buffer,20);
			    	temp_char[8] = '\0';
			    	if(strcmp(temp_char,"RF_START\0") == 0)
			    	{
			    		found = true;
			    		g_tpd_list->db_flags = DOING_ROLLFORWARD;
			    		fgets (buffer, 500, fp);
			    		fprintf(aux,"%s",buffer);
			    		buffer[strlen(buffer)-2] = '\0';
			    		get_token((buffer+16), &tok_list);
			    		do_semantic(tok_list);
						tok_ptr = tok_list;
			    	}
			    	else
			    	{
			    		fprintf(aux, "%s", buffer);
			    	}
				    tok_ptr = tok_list;
			    	while (tok_ptr != NULL)
					{
				      tmp_tok_ptr = tok_ptr->next;
				      free(tok_ptr);
				      tok_ptr=tmp_tok_ptr;
					}
				}

			}
			if(found == false)
			{
				rc = RF_START_MISSING;
				cur->tok_value = INVALID;
			}
			fflush(fp);
			fclose(fp);
			fp = NULL;			
			fflush(aux);
			fclose(aux);
			aux = NULL;
		}
		else
		{
			rc = LOG_FILE_NOT_EXIST;
			cur->tok_value = INVALID;
		}
		free(buffer);
		free(temp_char);	
	}
	else if(cur->tok_value == K_TO)
	{
		if(cur->next->tok_value != EOC)
		{
			if(cur->next->tok_value == INT_LITERAL)
			{
				if(strlen(cur->next->tok_string) != 14 )
		    	{
		    		rc = INVALID_TIMESTAMP;
		    		cur->next->tok_value = INVALID;
		    	}
		    	else
		    	{	
					if(cur->next->next->tok_value == EOC)
					{
						if(file_exist("db.log"))
						{
							fp = fopen("dbfile.bin", "wb");
							g_tpd_list->db_flags = 0;
							fwrite(g_tpd_list,g_tpd_list->list_size, 1,fp);
							fflush(fp);
							fclose(fp);
							fp = NULL;
							rename("db.log","db.old");
							fp = fopen("db.old","r");
							aux = fopen("db.log","w");
							buffer = (char *)calloc(500,sizeof(char));
							tolog = (char *)calloc(500,sizeof(char));
							temp_char = (char *)calloc(20,sizeof(char));
							date = (char *)calloc(15,sizeof(char));
							memcpy(date,cur->next->tok_string,14);
			    			date[14] = '\0';
			    			rtime1 = getTime(date);	
							while(fgets (buffer, 500, fp) != NULL)
							{
								memcpy(tolog,buffer,500);
								token_list *tok_list=NULL, *tok_ptr=NULL, *tmp_tok_ptr=NULL;
								if(found == true)
								{						    		
									memcpy(temp_char,buffer,10);
		    						temp_char[6] = '\0';
		    						if(strcmp(temp_char,"BACKUP\0") != 0)
		    						{
								    	memcpy(temp_char,buffer,20);
								    	temp_char[14] = '\0';
								    	rtime2 = getTime(temp_char);
								    	if(difftime(rtime1,rtime2) >= 0)
								    	{
							    			fprintf(aux,"%s",tolog);
								    		buffer[strlen(buffer)-2] = '\0';
								    		get_token((buffer+16), &tok_list);
								    		do_semantic(tok_list);
								    	}
								    	else
								    	{
								    		prune = true;
								    		break;
								    	}
								    }
								}
								if(found == false)
								{
							    	memcpy(temp_char,buffer,20);
							    	temp_char[8] = '\0';
							    	if(strcmp(temp_char,"RF_START\0") == 0)
							    	{
							    		found = true;
							    		g_tpd_list->db_flags = DOING_ROLLFORWARD;
							    		fgets (buffer, 500, fp);
							    		memcpy(tolog,buffer,500);
							    		memcpy(temp_char,buffer,10);
			    						temp_char[6] = '\0';
			    						if(strcmp(temp_char,"BACKUP\0") != 0)
			    						{
									    	memcpy(temp_char,buffer,20);
									    	temp_char[14] = '\0';
									    	rtime2 = getTime(temp_char);
									    	if(difftime(rtime1,rtime2) >= 0)
									    	{
								    			fprintf(aux,"%s",tolog);
									    		buffer[strlen(buffer)-2] = '\0';
									    		get_token((buffer+16), &tok_list);
									    		do_semantic(tok_list);
									    	}
									    	else
									    	{
									    		prune = true;
									    		break;
									    	}
									    }
							    	}
							    	else
							    	{
							    		fprintf(aux, "%s", tolog);
							    	}
								  	tok_ptr = tok_list;
							    	while (tok_ptr != NULL)
									{
								      tmp_tok_ptr = tok_ptr->next;
								      free(tok_ptr);
								      tok_ptr=tmp_tok_ptr;
									}
								}

							}
							if(found == false)
							{
								rc = RF_START_MISSING;
								cur->tok_value = INVALID;
							}
							fflush(fp);
							fclose(fp);
							fp = NULL;			
							fflush(aux);
							fclose(aux);
							aux = NULL;

						}
						else
						{
							rc = LOG_FILE_NOT_EXIST;
							cur->tok_value = INVALID;
						}
						free(buffer);
						free(temp_char);
						free(date);	
					}
					else
					{
						rc = MORE_ARGUMENTS_THAN_EXPECTED;
						cur->next->next->tok_value = INVALID;
					}
				}
			}
			else
			{
				rc = INVALID_LITERAL_VALUE;
				cur->next->tok_value = INVALID;
			}
		}
		else
		{
			rc = MISSING_ARGUMENTS;
			cur->tok_value = INVALID;
		}
	}
	else
	{
		rc = INVALID_STATEMENT;
		cur->tok_value = INVALID;
	}
	if(prune == true)
	{
		int k = 1;
		char number[5];
		char *file_name = (char *)calloc(10,sizeof(char));
		strcat(file_name,"db.log");
//		itoa(k, number, 10);
    	sprintf(number,"%d",k);
		strcat(file_name,number);
		while(file_exist(file_name))
		{
			k++;
			free(file_name);
			file_name = (char *)calloc(10,sizeof(char));
			strcat(file_name,"db.log");
      		sprintf(number,"%d",k);
//			itoa(k, number, 10);
			strcat(file_name,number);
		}
		rename("db.old",file_name);
		struct _stat st;
		FILE *remov = fopen(file_name, "rb" );
		_fstat(_fileno(remov), &st);
		char *readed = (char *)calloc(st.st_size,sizeof(char));
		fread(readed,1, st.st_size, remov);
		fclose(remov);
		size_t newSize = deleteLine( readed, st.st_size,"RF_START");
		remov = fopen(file_name, "wb" );
        fwrite(readed, 1, newSize, remov);
        fclose(remov);
        free(readed);
        free(file_name);	
	}
	return rc;
}
int initialize_tpd_list()
{
	int rc = 0;
	FILE *fhandle = NULL;
	struct _stat file_stat;

  /* Open for read */
  if((fhandle = fopen("dbfile.bin", "rbc")) == NULL)
	{
		if((fhandle = fopen("dbfile.bin", "wbc")) == NULL)
		{
			rc = FILE_OPEN_ERROR;
		}
   		 else
		{
			g_tpd_list = NULL;
			g_tpd_list = (tpd_list*)calloc(1, sizeof(tpd_list));
			
			if (!g_tpd_list)
			{
				rc = MEMORY_ERROR;
			}
			else
			{
				g_tpd_list->list_size = sizeof(tpd_list);
				fwrite(g_tpd_list, sizeof(tpd_list), 1, fhandle);
				fflush(fhandle);
				fclose(fhandle);
			}
		}
	}
	else
	{
		/* There is a valid dbfile.bin file - get file size */
		_fstat(_fileno(fhandle), &file_stat);
        printf("dbfile.bin size = %d\n", file_stat.st_size);

		g_tpd_list = (tpd_list*)calloc(1, file_stat.st_size);

		if (!g_tpd_list)
		{
			rc = MEMORY_ERROR;
		}
		else
		{
			fread(g_tpd_list, file_stat.st_size, 1, fhandle);
			fflush(fhandle);
			fclose(fhandle);

			if (g_tpd_list->list_size != file_stat.st_size)
			{
				rc = DBFILE_CORRUPTION;
			}

		}
	}
    
	return rc;
}
	
int add_tpd_to_list(tpd_entry *tpd)
{
	int rc = 0;
	int old_size = 0;
	FILE *fhandle = NULL;

	if((fhandle = fopen("dbfile.bin", "wbc")) == NULL)
	{
		rc = FILE_OPEN_ERROR;
	}
  else
	{
		old_size = g_tpd_list->list_size;

		if (g_tpd_list->num_tables == 0)
		{
			/* If this is an empty list, overlap the dummy header */
			g_tpd_list->num_tables++;
		 	g_tpd_list->list_size += (tpd->tpd_size - sizeof(tpd_entry));
			fwrite(g_tpd_list, old_size - sizeof(tpd_entry), 1, fhandle);
		}
		else
		{
			/* There is at least 1, just append at the end */
			g_tpd_list->num_tables++;
		 	g_tpd_list->list_size += tpd->tpd_size;
			fwrite(g_tpd_list, old_size, 1, fhandle);
		}

		fwrite(tpd, tpd->tpd_size, 1, fhandle);
		fflush(fhandle);
		fclose(fhandle);
	}

	return rc;
}

int drop_tpd_from_list(char *tabname)
{
	int rc = 0;
	tpd_entry *cur = &(g_tpd_list->tpd_start);
	int num_tables = g_tpd_list->num_tables;
	bool found = false;
	int count = 0;

	if (num_tables > 0)
	{
		while ((!found) && (num_tables-- > 0))
		{
			if (stricmp(cur->table_name, tabname) == 0)
			{
				/* found it */
				found = true;
				int old_size = 0;
				FILE *fhandle = NULL;

				if((fhandle = fopen("dbfile.bin", "wbc")) == NULL)
				{
					rc = FILE_OPEN_ERROR;
				}
			  else
				{
					old_size = g_tpd_list->list_size;

					if (count == 0)
					{
						/* If this is the first entry */
						g_tpd_list->num_tables--;

						if (g_tpd_list->num_tables == 0)
						{
							/* This is the last table, null out dummy header */
							memset((void*)g_tpd_list, '\0', sizeof(tpd_list));
							g_tpd_list->list_size = sizeof(tpd_list);
							fwrite(g_tpd_list, sizeof(tpd_list), 1, fhandle);
						}
						else
						{
							/* First in list, but not the last one */
							g_tpd_list->list_size -= cur->tpd_size;

							/* First, write the 8 byte header */
							fwrite(g_tpd_list, sizeof(tpd_list) - sizeof(tpd_entry),
								     1, fhandle);

							/* Now write everything starting after the cur entry */
							fwrite((char*)cur + cur->tpd_size,
								     old_size - cur->tpd_size -
										 (sizeof(tpd_list) - sizeof(tpd_entry)),
								     1, fhandle);
						}
					}
					else
					{
						/* This is NOT the first entry - count > 0 */
						g_tpd_list->num_tables--;
					 	g_tpd_list->list_size -= cur->tpd_size;

						/* First, write everything from beginning to cur */
						fwrite(g_tpd_list, ((char*)cur - (char*)g_tpd_list),
									 1, fhandle);

						/* Check if cur is the last entry. Note that g_tdp_list->list_size
						   has already subtracted the cur->tpd_size, therefore it will
						   point to the start of cur if cur was the last entry */
						if ((char*)g_tpd_list + g_tpd_list->list_size == (char*)cur)
						{
							/* If true, nothing else to write */
						}
						else
						{
							/* NOT the last entry, copy everything from the beginning of the
							   next entry which is (cur + cur->tpd_size) and the remaining size */
							fwrite((char*)cur + cur->tpd_size,
										 old_size - cur->tpd_size -
										 ((char*)cur - (char*)g_tpd_list),							     
								     1, fhandle);
						}
					}

					fflush(fhandle);
					fclose(fhandle);
				}

				
			}
			else
			{
				if (num_tables > 0)
				{
					cur = (tpd_entry*)((char*)cur + cur->tpd_size);
					count++;
				}
			}
		}
	}
	
	if (!found)
	{
		rc = INVALID_TABLE_NAME;
	}

	return rc;
}

tpd_entry* get_tpd_from_list(char *tabname)
{
	tpd_entry *tpd = NULL;
	tpd_entry *cur = &(g_tpd_list->tpd_start);
	int num_tables = g_tpd_list->num_tables;
	bool found = false;

	if (num_tables > 0)
	{
		while ((!found) && (num_tables-- > 0))
		{
			if (stricmp(cur->table_name, tabname) == 0)
			{
				/* found it */
				found = true;
				tpd = cur;
			}
			else
			{
				if (num_tables > 0)
				{
					cur = (tpd_entry*)((char*)cur + cur->tpd_size);
				}
			}
		}
	}

	return tpd;
}


int create_table_file(const char * table_name, tpd_entry *new_entry)
{
  int rc = 0;
  int record_size = 0;
  FILE *fhandle = NULL;

  table_file_header *tab_file_header = (table_file_header*)calloc(1,sizeof(table_file_header));
  tab_file_header->record_offset = sizeof(table_file_header);
  tab_file_header->num_records = 0;
  tab_file_header->file_size = sizeof(table_file_header);

  cd_entry *col_entry = ((cd_entry*)((char*)new_entry + sizeof(tpd_entry)));

  tab_file_header->record_size = 0;
  for( int i = 0; i < new_entry->num_columns; i++, col_entry++ )
  {
    record_size += col_entry->col_len + 1;
  }

  tab_file_header->record_offset= sizeof(table_file_header);

  if(record_size%4 != 0)
    record_size += 4 - record_size%4;

  tab_file_header->record_size = record_size;

  char *  file_full_name = (char *)calloc(strlen(table_name) + 5, sizeof(char));
  strcat(file_full_name,table_name);
  strcat(file_full_name,".dat");

  if((fhandle = fopen(file_full_name, "wbc")) == NULL)
  {
    rc = FILE_OPEN_ERROR;
  }
  else
  {
    fwrite(tab_file_header, sizeof(table_file_header), 1, fhandle);
    fflush(fhandle);
    fclose(fhandle);
  }

  free(file_full_name);
  return rc;
}

int load_table(token_list *cur)
{

  int rc = 0;
  tpd_entry *new_entry = NULL;

  FILE *fhandle = NULL;
  struct _stat file_stat;

  //If table name does not exist
  if((new_entry = get_tpd_from_list(cur->tok_string)) == NULL)
  {
    rc = TABLE_NOT_EXIST;
    cur->tok_value = INVALID;
  }
  else//The table exists
  {

    int i = 0;
    char * table_file_name = (char *)calloc(strlen(cur->tok_string) + 5,sizeof(char));

    strcat(table_file_name,cur->tok_string);
    strcat(table_file_name,".dat\0");

    //If the table file does not exist
    if((fhandle = fopen(table_file_name, "rbc")) == NULL)
    {
      rc = FILE_OPEN_ERROR;

    }
    else//the table file exists
    {

      /* There is a valid table file - get file size */
      _fstat(_fileno(fhandle), &file_stat);

      tab_file_header = (table_file_header*)calloc(1, sizeof(table_file_header));


      //If there is no enough memory
      if (!tab_file_header)
      {
        rc = MEMORY_ERROR;
      }
      else//There is enough memory
      {


        fread(tab_file_header, sizeof(table_file_header), 1, fhandle);

        //If the table file is corrupted

        if (tab_file_header->file_size != file_stat.st_size)
        {
          rc = DBFILE_CORRUPTION;
          printf("%d != %d\n\n",tab_file_header->file_size,file_stat.st_size);

        }
        else//The table file is not corrupted
        {

          //Update tpd_ptr
          tab_file_header->tpd_ptr = new_entry;
          current_table_data = (unsigned char**)malloc(100*sizeof(char*));

          //Allocate memory for each record
          for( i = 0; i < 100; i++ )
          {
            current_table_data[i] = (unsigned char*)malloc(tab_file_header->record_size);
            if(i < tab_file_header->num_records)
            {
              fread(current_table_data[i], tab_file_header->record_size, 1, fhandle);

            }else
              memset(current_table_data[i],0,tab_file_header->record_size);
          }
        }

        fflush(fhandle);
        fclose(fhandle);
      }
    }

  }
  return rc;
}


void display_table()
{

  int i = 0;
  cd_entry *col_entry = (cd_entry*)((char *)(tab_file_header->tpd_ptr) + sizeof(tpd_entry));

  //Print heading
  for( int j = 0; j < tab_file_header->tpd_ptr->num_columns; j++ )
  {
      if( col_entry[j].col_type == T_INT )
      {
          if(col_entry[j].col_id == 0)
              printf("%10s",col_entry[j].col_name);
          else
              printf(" %10s",col_entry[j].col_name);
      }
      else if(col_entry[j].col_type==T_CHAR)
      {
          printf(" %-14s",col_entry[j].col_name);
      }

  }
  printf("\n");


  //Print data
  for( i = 0; i < tab_file_header->num_records; i++)
  {
    unsigned char * current_row  = current_table_data[i];
    for( int j = 0; j < tab_file_header->tpd_ptr->num_columns; j++)
    {
      if(col_entry[j].col_type==T_INT)
      {
        int size = (*current_row);
        current_row++;
        if(size != 0)
        {
          int value;
          memcpy(reinterpret_cast<char*>(&value),current_row,col_entry[j].col_len);
          if(col_entry[j].col_id == 0)
              printf("%10d",value);
          else
          printf(" %10d",value);
        }
        else
        {
          printf(" %10s","NULL");
        }
        current_row+=col_entry[j].col_len;
      }
      else if(col_entry[j].col_type==T_CHAR)
      {
        int size = (int)*current_row;
        current_row++;
        if( size != 0 )
        {
        char value[256];
        memcpy(value,current_row,size);
        value[size] = '\0';
        printf(" %-14s",value);
        }
        else
          printf(" %-14s","NULL");
        current_row+=col_entry[j].col_len;
      }

    }
    printf("\n");
  }
}

void delete_table_data()
{
  free(tab_file_header);
  if(current_table_data != NULL)
  {
    int i;
    for( i = 0;  i < 100; i++)
      free(current_table_data[i]);

    free(current_table_data);
    current_table_data = NULL;
  }
}

int file_exist (char *filename)
{
  struct stat   buffer;   
  return (stat (filename, &buffer) == 0);
}

time_t getTime(char *szYYYYMMDDHHMMSS)
{
struct tm    Tm;    
    memset(&Tm, 0, sizeof(Tm));
    char buffer[5];
    /*YEAR*/
    memcpy(buffer,szYYYYMMDDHHMMSS,sizeof(char)*4);
    buffer[4] = '\0';
    szYYYYMMDDHHMMSS+=4;
    Tm.tm_year = atoi(buffer)- 1900;
    /*MON*/
    memcpy(buffer,szYYYYMMDDHHMMSS,sizeof(char)*2);
    buffer[2] = '\0';
    szYYYYMMDDHHMMSS+=2;
    Tm.tm_mon  = atoi(buffer) - 1;
    /*Day*/
    memcpy(buffer,szYYYYMMDDHHMMSS,sizeof(char)*2);
    buffer[2] = '\0';
    szYYYYMMDDHHMMSS+=2;
    Tm.tm_mday = atoi(buffer);
    /*HOUR*/
    memcpy(buffer,szYYYYMMDDHHMMSS,sizeof(char)*2);
    buffer[2] = '\0';
    szYYYYMMDDHHMMSS+=2;
    Tm.tm_hour = atoi(buffer);
    /*MIN*/
    memcpy(buffer,szYYYYMMDDHHMMSS,sizeof(char)*2);
    buffer[2] = '\0';
    szYYYYMMDDHHMMSS+=2;
    Tm.tm_min  = atoi(buffer);
    /*SEC*/
    memcpy(buffer,szYYYYMMDDHHMMSS,sizeof(char)*2);
    buffer[2] = '\0';
    szYYYYMMDDHHMMSS+=2;
    Tm.tm_sec  = atoi(buffer);
    return mktime(&Tm);
}

size_t deleteLine( char* buffer, size_t size, const char* line )
{
  char* p = buffer; 
  bool done = false;
  size_t len = strlen(line);
  size_t newSize = 0;
  do
  {
    char* q = strchr( p, *line );
    if ( q != NULL )
    {
      if ( strncmp( q, line, len ) == 0 )
      {
        size_t lineSize = 1; 
        for ( char* line = q; *line != '\n'; ++line) 
        {
          ++lineSize;
        }
        size_t restSize = (size_t)((buffer + size) - (q + lineSize));
        memmove( q, q + lineSize, restSize );
        newSize = size - lineSize;
        done = true;
      }
      else
      {
        p = q + 1; // continue search
      }
    }
    else
    {
      done = true;
    }
  }
  while (!done);

  return newSize;
}
db.cpp
1 of 4 items
db.cppdb.hp1list_2.pdfp1list_3.pdfDisplaying db.cpp.